diff -ur ircd-hybrid/contrib/m_clearchan.c new/contrib/m_clearchan.c
--- ircd-hybrid/contrib/m_clearchan.c	Sun Oct 12 19:38:18 2003
+++ new/contrib/m_clearchan.c	Sat Jan 17 12:09:03 2004
@@ -197,6 +197,7 @@
 remove_our_modes(struct Channel *chptr, struct Client *source_p)
 {
   remove_a_mode(chptr, CHFL_CHANOP, 'o');
+  remove_a_mode(chptr, CHFL_HALFOP, 'h');
   remove_a_mode(chptr, CHFL_VOICE, 'v');
 
   /* Clear all +beI modes */
diff -ur ircd-hybrid/contrib/m_ojoin.c new/contrib/m_ojoin.c
--- ircd-hybrid/contrib/m_ojoin.c	Wed Oct 22 02:08:46 2003
+++ new/contrib/m_ojoin.c	Sat Jan 17 12:09:03 2004
@@ -103,6 +103,8 @@
                 modeletter = 'o'; name++; break;
       case '+': tmp_flags = CHFL_VOICE;
                 modeletter = 'v'; name++; break;
+      case '%': tmp_flags = CHFL_HALFOP;
+                modeletter = 'h'; name++; break;
       case '#':
       case '&':
         tmp_flags = 0;
diff -ur ircd-hybrid/include/supported.h new/include/supported.h
--- ircd-hybrid/include/supported.h	Sat Sep 27 19:16:03 2003
+++ new/include/supported.h	Sat Jan 17 12:09:03 2004
@@ -56,7 +56,7 @@
 		  " CALLERID%s"
 
 #define FEATURES2VALUES ConfigChannel.disable_local_channels ? "#" : "#&", \
-                        "(ov)@+", \
+                        "(ohv)@%+", \
                         ConfigChannel.use_except ? "e" : "", \
                         ConfigChannel.use_invex ? "I" : "", \
                         "b,k,l,imnpst", \
diff -ur ircd-hybrid/modules/core/m_join.c new/modules/core/m_join.c
--- ircd-hybrid/modules/core/m_join.c	Tue Nov  4 14:30:01 2003
+++ new/modules/core/m_join.c	Sat Jan 17 12:09:03 2004
@@ -713,6 +713,7 @@
 remove_our_modes(struct Channel *chptr, struct Client *source_p)
 {
   remove_a_mode(chptr, source_p, CHFL_CHANOP, 'o');
+  remove_a_mode(chptr, source_p, CHFL_HALFOP, 'h');
   remove_a_mode(chptr, source_p, CHFL_VOICE, 'v');
 }
 
diff -ur ircd-hybrid/modules/core/m_kick.c new/modules/core/m_kick.c
--- ircd-hybrid/modules/core/m_kick.c	Tue Nov  4 14:30:01 2003
+++ new/modules/core/m_kick.c	Sat Jan 17 12:09:03 2004
@@ -135,7 +135,7 @@
         return;
       }
     }
-    if (!has_member_flags(ms, CHFL_CHANOP))
+    if (!has_member_flags(ms, CHFL_CHANOP|CHFL_HALFOP))
     {
       /* was a user, not a server, and user isn't seen as a chanop here */
       if (MyConnect(source_p))
@@ -193,6 +193,17 @@
 
   if ((ms_target = find_channel_link(who, chptr)) != NULL)
   {
+    /* half ops cannot kick other halfops on private channels */
+    if (has_member_flags(ms, CHFL_HALFOP) && !has_member_flags(ms, CHFL_CHANOP))
+    {
+      if (((chptr->mode.mode & MODE_PRIVATE) && has_member_flags(ms_target, CHFL_CHANOP|CHFL_HALFOP)) ||
+            has_member_flags(ms_target, CHFL_CHANOP))
+      {
+        sendto_one(source_p, form_str(ERR_CHANOPRIVSNEEDED),
+                   me.name, source_p->name, name);
+        return;
+      }
+    }
    /* jdc
     * - In the case of a server kicking a user (i.e. CLEARCHAN),
     *   the kick should show up as coming from the server which did
diff -ur ircd-hybrid/modules/core/m_sjoin.c new/modules/core/m_sjoin.c
--- ircd-hybrid/modules/core/m_sjoin.c	Sat Jan 17 12:08:41 2004
+++ new/modules/core/m_sjoin.c	Sat Jan 17 12:13:24 2004
@@ -109,11 +109,10 @@
   int            isnew;
   int            buflen = 0;
   int		 slen;
-  char           *s, *nhops;
+  char           *s;
   char		 *sptr;
   static         char nick_buf[2*BUFSIZE]; /* buffer for modes and prefix */
   static         char uid_buf[2*BUFSIZE];  /* buffer for modes/prefixes for CAP_TS6 servers */
-  static         char sjbuf_nhops[BUFSIZE]; /* buffer with halfops as @ */
   char           *nick_ptr, *uid_ptr;      /* pointers used for making the two mode/prefix buffers */
   char           *p; /* pointer used making sjbuf */
   int            i;
@@ -121,8 +120,6 @@
   const char *servername = (ConfigServerHide.hide_servers || IsHidden(source_p)) ?
 			    me.name : source_p->name;  
 
-  sjbuf_nhops[0] = '\0';
-
   if (IsClient(source_p) || parc < 5)
     return;
 
@@ -316,8 +313,6 @@
 
   *mbuf++ = '+';
 
-  nhops = sjbuf_nhops;
-
   s = parv[args + 4];
 
   /* remove any leading spaces */
@@ -336,7 +331,7 @@
     fl = 0;
     num_prefix = 0;
 
-    for (i = 0; i < 2; i++)
+    for (i = 0; i < 3; i++)
     {
       if (*s == '@')
       {
@@ -348,6 +343,11 @@
         fl |= CHFL_VOICE;
         s++;
       }
+      else if (*s == '%')
+      {
+        fl |= CHFL_HALFOP;
+        s++;
+      }
     }
 
     target_p = find_person(s);
@@ -372,6 +372,11 @@
         *nick_ptr++ = '@';
         *uid_ptr++  = '@';
       }
+      if (fl & CHFL_HALFOP)
+      {
+        *nick_ptr++ = '%';
+        *uid_ptr++  = '%';
+      }
       if (fl & CHFL_VOICE)
       {
         *nick_ptr++ = '+';
@@ -385,7 +390,7 @@
 
     if (!keep_new_modes)
     {
-      if (fl & CHFL_CHANOP)
+      if (fl & (CHFL_CHANOP|CHFL_HALFOP))
         fl = CHFL_DEOPPED;
       else
         fl = 0;
@@ -488,6 +493,30 @@
         pargs = 0;
       }
     }
+    if (fl & CHFL_HALFOP)
+    {
+      *mbuf++ = 'h';
+      para[pargs++] = target_p->name;
+
+      if (pargs >= MAXMODEPARAMS)
+      {
+        sptr = sendbuf;
+        *mbuf = '\0';
+        for(lcount = 0; lcount < MAXMODEPARAMS; lcount++)
+        {
+          slen = ircsprintf(sptr, " %s", para[lcount]);
+          sptr += slen;
+        }
+        sendto_channel_local(ALL_MEMBERS, chptr, ":%s MODE %s %s%s",
+                             servername, chptr->chname, modebuf, sendbuf);
+
+        mbuf = modebuf;
+        *mbuf++ = '+';
+
+        sendbuf[0] = '\0';
+        pargs = 0;
+      }
+    }
 
 nextnick:
     /* p points to the next nick */
@@ -674,6 +703,7 @@
 remove_our_modes(struct Channel *chptr, struct Client *source_p)
 {
   remove_a_mode(chptr, source_p, CHFL_CHANOP, 'o');
+  remove_a_mode(chptr, source_p, CHFL_HALFOP, 'h');
   remove_a_mode(chptr, source_p, CHFL_VOICE, 'v');
 }
 
diff -ur ircd-hybrid/src/channel_mode.c new/src/channel_mode.c
--- ircd-hybrid/src/channel_mode.c	Thu Oct 16 16:42:09 2003
+++ new/src/channel_mode.c	Sat Jan 17 12:09:03 2004
@@ -72,6 +72,10 @@
 static void chm_op(struct Client *, struct Client *, struct Channel *, int,
                    int *, char **, int *, int, int, char, void *,
                    const char *chname);
+static void chm_hop(struct Client *, struct Client *, struct Channel *, int,
+                   int *, char **, int *, int, int, char, void *,
+                   const char *chname);
+
 static void chm_voice(struct Client *, struct Client *, struct Channel *,
                       int, int *, char **, int *, int, int, char, void *,
                       const char *chname);
@@ -647,7 +651,11 @@
 
   mode_type = (long)d;
 
-  if (alev < CHACCESS_CHANOP)
+  /* dont allow halfops to set +-p, as this controls whether they can set
+   * +-h or not.. all other simple modes are ok   
+   */ 
+  if ((alev < CHACCESS_HALFOP) ||
+      ((mode_type == MODE_PRIVATE) && (alev < CHACCESS_CHANOP)))
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -728,7 +736,7 @@
     return;
   }
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -822,7 +830,7 @@
     return;
   }
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -925,7 +933,7 @@
     return;
   }
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -1086,6 +1094,95 @@
 }
 
 static void
+chm_hop(struct Client *client_p, struct Client *source_p,
+       struct Channel *chptr, int parc, int *parn,
+       char **parv, int *errors, int alev, int dir, char c, void *d,
+       const char *chname)
+{
+  char *opnick;
+  struct Client *targ_p;
+  struct Membership *member;
+
+  /* *sigh* - dont allow halfops to set +/-h, they could fully control a
+   * channel if there were no ops - it doesnt solve anything.. MODE_PRIVATE
+   * when used with MODE_SECRET is paranoid - cant use +p
+   *
+   * it needs to be optional per channel - but not via +p, that or remove
+   * paranoid.. -- fl_
+   *
+   * +p means paranoid, it is useless for anything else on modern IRC, as
+   * list isn't really usable. If you want to have a private channel these
+   * days, you set it +s. Halfops can no longer remove simple modes when
+   * +p is set (although they can set +p) so it is safe to use this to
+   * control whether they can (de)halfop...
+   */
+  if (alev <
+      ((chptr->mode.mode & MODE_PRIVATE) ? CHACCESS_CHANOP : CHACCESS_HALFOP))
+  {
+    if (!(*errors & SM_ERR_NOOPS))
+      sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
+                                    ERR_NOTONCHANNEL : ERR_CHANOPRIVSNEEDED),
+                 me.name, source_p->name, chname); 
+    *errors |= SM_ERR_NOOPS;
+    return;
+  }
+  if ((dir == MODE_QUERY) || (parc <= *parn))
+    return;
+
+  if (IsRestricted(source_p) && (dir == MODE_ADD))
+  {
+    if (!(*errors & SM_ERR_RESTRICTED))
+      sendto_one(source_p,
+                 ":%s NOTICE %s :*** Notice -- You are restricted and cannot "
+                 "chanop others", me.name, source_p->name);
+
+    *errors |= SM_ERR_RESTRICTED;
+    return;
+  }
+
+  opnick = parv[(*parn)++];
+
+  if ((targ_p = find_chasing(source_p, opnick, NULL)) == NULL)
+    return;
+  if (!IsClient(targ_p))
+    return;
+
+  if ((member = find_channel_link(targ_p, chptr)) == NULL)
+  {
+    if (!(*errors & SM_ERR_NOTONCHANNEL))
+      sendto_one(source_p, form_str(ERR_USERNOTINCHANNEL),
+                 me.name, source_p->name, opnick, chname);
+    *errors |= SM_ERR_NOTONCHANNEL;
+    return;
+  }
+
+  if (MyClient(source_p) && (++mode_limit > MAXMODEPARAMS))
+    return;
+
+  /* no redundant mode changes */
+  if (dir == MODE_ADD &&  has_member_flags(member, CHFL_HALFOP))
+    return;
+  if (dir == MODE_DEL && !has_member_flags(member, CHFL_HALFOP))
+    return;
+
+  mode_changes[mode_count].letter = 'h';
+  mode_changes[mode_count].dir = dir;
+  mode_changes[mode_count].caps = 0;
+  mode_changes[mode_count].nocaps = 0;
+  mode_changes[mode_count].mems = ALL_MEMBERS;
+  mode_changes[mode_count].id = targ_p->id;
+  mode_changes[mode_count].arg = targ_p->name;
+  mode_changes[mode_count++].client = targ_p;
+
+  if (dir == MODE_ADD)
+  {
+    AddMemberFlag(member, CHFL_HALFOP);
+    DelMemberFlag(member, CHFL_DEOPPED);
+  }
+  else DelMemberFlag(member, CHFL_HALFOP);
+}
+
+static void
 chm_voice(struct Client *client_p, struct Client *source_p,
           struct Channel *chptr, int parc, int *parn,
           char **parv, int *errors, int alev, int dir, char c, void *d,
@@ -1095,7 +1192,7 @@
   struct Client *targ_p;
   struct Membership *member;
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -1157,7 +1254,7 @@
   int i, limit;
   char *lstr;
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -1222,7 +1319,7 @@
   int i;
   char *key;
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -1337,7 +1434,7 @@
   {chm_except, NULL},                             /* e */
   {chm_nosuch, NULL},                             /* f */
   {chm_nosuch, NULL},                             /* g */
-  {chm_nosuch, NULL},				  /* h */
+  {chm_hop, NULL},                                /* h */
   {chm_simple, (void *) MODE_INVITEONLY},         /* i */
   {chm_nosuch, NULL},                             /* j */
   {chm_key, NULL},                                /* k */
@@ -1382,6 +1479,9 @@
 
   if (has_member_flags(member, CHFL_CHANOP))
     return(CHACCESS_CHANOP);
+
+  if (has_member_flags(member, CHFL_HALFOP))
+    return(CHACCESS_HALFOP);
 
   return(CHACCESS_PEON);
 }
