diff -ur nohalfops/contrib/m_ojoin.c halfops/contrib/m_ojoin.c
--- nohalfops/contrib/m_ojoin.c	Sat Oct 11 11:17:48 2003
+++ halfops/contrib/m_ojoin.c	Sat Oct 11 11:17:54 2003
@@ -103,6 +103,8 @@
                 modeletter = 'o'; name++; break;
       case '+': tmp_flags = CHFL_VOICE;
                 modeletter = 'v'; name++; break;
+      case '%': tmp_flags = CHFL_HALFOP;
+                modeletter = 'h'; name++; break;
       case '#':
       case '&':
         tmp_flags = 0;
diff -ur nohalfops/modules/core/m_kick.c halfops/modules/core/m_kick.c
--- nohalfops/modules/core/m_kick.c	Sat Oct 11 11:17:48 2003
+++ halfops/modules/core/m_kick.c	Sat Oct 11 11:17:54 2003
@@ -135,7 +135,7 @@
         return;
       }
     }
-    if (!has_member_flags(ms, CHFL_CHANOP))
+    if (!has_member_flags(ms, CHFL_CHANOP|CHFL_HALFOP))
     {
       /* was a user, not a server, and user isn't seen as a chanop here */
       if (MyConnect(source_p))
@@ -193,6 +193,17 @@
 
   if ((ms_target = find_channel_link(who, chptr)) != NULL)
   {
+    /* half ops cannot kick other halfops on private channels */
+    if (has_member_flags(ms, CHFL_HALFOP) && !has_member_flags(ms, CHFL_CHANOP))
+    {
+      if (((chptr->mode.mode & MODE_PRIVATE) && has_member_flags(ms_target, CHFL_CHANOP|CHFL_HALFOP)) ||
+            has_member_flags(ms_target, CHFL_CHANOP))
+      {
+        sendto_one(source_p, form_str(ERR_CHANOPRIVSNEEDED),
+                   me.name, source_p->name, name);
+        return;
+      }
+    }
    /* jdc
     * - In the case of a server kicking a user (i.e. CLEARCHAN),
     *   the kick should show up as coming from the server which did
diff -ur nohalfops/modules/core/m_sjoin.c halfops/modules/core/m_sjoin.c
--- nohalfops/modules/core/m_sjoin.c	Sat Oct 11 11:17:48 2003
+++ halfops/modules/core/m_sjoin.c	Sat Oct 11 11:18:15 2003
@@ -318,7 +318,7 @@
     fl = 0;
     num_prefix = 0;
 
-    for (i = 0; i < 2; i++)
+    for (i = 0; i < 3; i++)
     {
       if (*s == '@')
       {
@@ -330,6 +330,16 @@
         fl |= CHFL_VOICE;
         s++;
       }
+      else if (*s == '%')
+      {
+        fl |= CHFL_HALFOP;
+        if (keep_new_modes)
+        {
+          *nhops++ = *s;
+          num_prefix++;
+        }
+        s++;
+      }
     }
 
     if (IsDigit(*s))
@@ -370,7 +380,7 @@
 
     if (!keep_new_modes)
     {
-      if (fl & CHFL_CHANOP)
+      if (fl & (CHFL_CHANOP|CHFL_HALFOP))
         fl = CHFL_DEOPPED;
       else
         fl = 0;
@@ -453,6 +463,24 @@
         pargs = 0;
       }
     }
+    if (fl & CHFL_HALFOP)
+    {
+      *mbuf++ = 'h';
+      para[pargs++] = s;
+
+      if (pargs >= MAXMODEPARAMS)
+      {
+        *mbuf = '\0';
+        sendto_channel_local(ALL_MEMBERS, chptr, ":%s MODE %s %s %s %s %s %s",
+                             servername, chptr->chname, modebuf, para[0],
+                             para[1], para[2], para[3]);
+        mbuf = modebuf;
+        *mbuf++ = '+';
+
+        para[0] = para[1] = para[2] = para[3] = "";
+        pargs = 0;
+      }
+    }
 
 nextnick:
     /* p points to the next nick */
@@ -641,6 +669,7 @@
 remove_our_modes(struct Channel *chptr, struct Client *source_p)
 {
   remove_a_mode(chptr, source_p, CHFL_CHANOP, 'o');
+  remove_a_mode(chptr, source_p, CHFL_HALFOP, 'h');
   remove_a_mode(chptr, source_p, CHFL_VOICE, 'v');
 }
 
diff -ur nohalfops/src/channel_mode.c halfops/src/channel_mode.c
--- nohalfops/src/channel_mode.c	Sat Oct 11 11:17:48 2003
+++ halfops/src/channel_mode.c	Sat Oct 11 11:17:54 2003
@@ -72,6 +72,10 @@
 static void chm_op(struct Client *, struct Client *, struct Channel *, int,
                    int *, char **, int *, int, int, char, void *,
                    const char *chname);
+static void chm_hop(struct Client *, struct Client *, struct Channel *, int,
+                   int *, char **, int *, int, int, char, void *,
+                   const char *chname);
+
 static void chm_voice(struct Client *, struct Client *, struct Channel *,
                       int, int *, char **, int *, int, int, char, void *,
                       const char *chname);
@@ -647,7 +651,11 @@
 
   mode_type = (long)d;
 
-  if (alev < CHACCESS_CHANOP)
+  /* dont allow halfops to set +-p, as this controls whether they can set
+   * +-h or not.. all other simple modes are ok   
+   */ 
+  if ((alev < CHACCESS_HALFOP) ||
+      ((mode_type == MODE_PRIVATE) && (alev < CHACCESS_CHANOP)))
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -728,7 +736,7 @@
     return;
   }
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -822,7 +830,7 @@
     return;
   }
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -925,7 +933,7 @@
     return;
   }
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -1086,6 +1094,95 @@
 }
 
 static void
+chm_hop(struct Client *client_p, struct Client *source_p,
+       struct Channel *chptr, int parc, int *parn,
+       char **parv, int *errors, int alev, int dir, char c, void *d,
+       const char *chname)
+{
+  char *opnick;
+  struct Client *targ_p;
+  struct Membership *member;
+
+  /* *sigh* - dont allow halfops to set +/-h, they could fully control a
+   * channel if there were no ops - it doesnt solve anything.. MODE_PRIVATE
+   * when used with MODE_SECRET is paranoid - cant use +p
+   *
+   * it needs to be optional per channel - but not via +p, that or remove
+   * paranoid.. -- fl_
+   *
+   * +p means paranoid, it is useless for anything else on modern IRC, as
+   * list isn't really usable. If you want to have a private channel these
+   * days, you set it +s. Halfops can no longer remove simple modes when
+   * +p is set (although they can set +p) so it is safe to use this to
+   * control whether they can (de)halfop...
+   */
+  if (alev <
+      ((chptr->mode.mode & MODE_PRIVATE) ? CHACCESS_CHANOP : CHACCESS_HALFOP))
+  {
+    if (!(*errors & SM_ERR_NOOPS))
+      sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
+                                    ERR_NOTONCHANNEL : ERR_CHANOPRIVSNEEDED),
+                 me.name, source_p->name, chname); 
+    *errors |= SM_ERR_NOOPS;
+    return;
+  }
+  if ((dir == MODE_QUERY) || (parc <= *parn))
+    return;
+
+  if (IsRestricted(source_p) && (dir == MODE_ADD))
+  {
+    if (!(*errors & SM_ERR_RESTRICTED))
+      sendto_one(source_p,
+                 ":%s NOTICE %s :*** Notice -- You are restricted and cannot "
+                 "chanop others", me.name, source_p->name);
+
+    *errors |= SM_ERR_RESTRICTED;
+    return;
+  }
+
+  opnick = parv[(*parn)++];
+
+  if ((targ_p = find_chasing(source_p, opnick, NULL)) == NULL)
+    return;
+  if (!IsClient(targ_p))
+    return;
+
+  if ((member = find_channel_link(targ_p, chptr)) == NULL)
+  {
+    if (!(*errors & SM_ERR_NOTONCHANNEL))
+      sendto_one(source_p, form_str(ERR_USERNOTINCHANNEL),
+                 me.name, source_p->name, opnick, chname);
+    *errors |= SM_ERR_NOTONCHANNEL;
+    return;
+  }
+
+  if (MyClient(source_p) && (++mode_limit > MAXMODEPARAMS))
+    return;
+
+  /* no redundant mode changes */
+  if (dir == MODE_ADD &&  has_member_flags(member, CHFL_HALFOP))
+    return;
+  if (dir == MODE_DEL && !has_member_flags(member, CHFL_HALFOP))
+    return;
+
+  mode_changes[mode_count].letter = 'h';
+  mode_changes[mode_count].dir = dir;
+  mode_changes[mode_count].caps = 0;
+  mode_changes[mode_count].nocaps = 0;
+  mode_changes[mode_count].mems = ALL_MEMBERS;
+  mode_changes[mode_count].id = targ_p->id;
+  mode_changes[mode_count].arg = targ_p->name;
+  mode_changes[mode_count++].client = targ_p;
+
+  if (dir == MODE_ADD)
+  {
+    AddMemberFlag(member, CHFL_HALFOP);
+    DelMemberFlag(member, CHFL_DEOPPED);
+  }
+  else DelMemberFlag(member, CHFL_HALFOP);
+}
+
+static void
 chm_voice(struct Client *client_p, struct Client *source_p,
           struct Channel *chptr, int parc, int *parn,
           char **parv, int *errors, int alev, int dir, char c, void *d,
@@ -1095,7 +1192,7 @@
   struct Client *targ_p;
   struct Membership *member;
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -1157,7 +1254,7 @@
   int i, limit;
   char *lstr;
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -1222,7 +1319,7 @@
   int i;
   char *key;
 
-  if (alev < CHACCESS_CHANOP)
+  if (alev < CHACCESS_HALFOP)
   {
     if (!(*errors & SM_ERR_NOOPS))
       sendto_one(source_p, form_str(alev == CHACCESS_NOTONCHAN ?
@@ -1337,7 +1434,7 @@
   {chm_except, NULL},                             /* e */
   {chm_nosuch, NULL},                             /* f */
   {chm_nosuch, NULL},                             /* g */
-  {chm_nosuch, NULL},				  /* h */
+  {chm_hop, NULL},                                /* h */
   {chm_simple, (void *) MODE_INVITEONLY},         /* i */
   {chm_nosuch, NULL},                             /* j */
   {chm_key, NULL},                                /* k */
@@ -1382,6 +1479,9 @@
 
   if (has_member_flags(member, CHFL_CHANOP))
     return(CHACCESS_CHANOP);
+
+  if (has_member_flags(member, CHFL_HALFOP))
+    return(CHACCESS_HALFOP);
 
   return(CHACCESS_PEON);
 }
