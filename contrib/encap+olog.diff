diff -uNr ircd-hybrid/contrib/m_operspy.c ircd-hybrid+encap+olog/contrib/m_operspy.c
--- ircd-hybrid/contrib/m_operspy.c	Mon Jun  9 20:37:12 2003
+++ ircd-hybrid+encap+olog/contrib/m_operspy.c	Mon Jun  9 20:42:14 2003
@@ -16,7 +16,7 @@
  *   along with this program; if not, write to the Free Software
  *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- *   $Id: encap+olog.diff,v 1.1 2003/06/10 02:16:50 bill Exp $
+ *   $Id: encap+olog.diff,v 1.1 2003/06/10 02:16:50 bill Exp $
  */
 
 /***  PLEASE READ ME  ***/
@@ -49,6 +49,12 @@
 #include "parse.h"
 #include "modules.h"
 
+/* enable per-oper logging of OPERSPY functions */
+#define OPERSPY_LOG
+
+/* enable this to send incoming operspy usage to active +y (FLAGS_SPY) opers */
+#define OPERSPY_NOTICE
+
 /* enable OPERSPY version of LIST */
 #define OPERSPY_LIST
 
@@ -74,6 +80,8 @@
  */
 static void m_operspy(struct Client *client_p, struct Client *source_p,
                        int parc, char *parv[]);
+static void ms_operspy(struct Client *client_p, struct Client *source_p,
+                       int parc, char *parv[]);
 static void mo_operspy(struct Client *client_p, struct Client *source_p,
                        int parc, char *parv[]);
 
@@ -107,9 +115,11 @@
 
 #endif
 
+static void sendto_match_servs(struct Client *, const char *, int, const char *, ...);
+
 struct Message operspy_msgtab = {
   "OPERSPY", 0, 0, 0, 0, MFLG_SLOW|MFLG_HIDDEN, 0,
-  {m_ignore, m_operspy, m_operspy, mo_operspy}
+  {m_ignore, m_operspy, ms_operspy, mo_operspy}
 };
 
 #ifndef STATIC_MODULES
@@ -124,7 +134,11 @@
 {
   mod_del_cmd(&operspy_msgtab);
 }
-const char *_version = "$Revision: 1.1 $";
+const char *_version = "$Revision: 1.1 $";
+#endif
+
+#ifdef OPERSPY_LOG
+static void operspy_log(struct Client *, const char *, const char *);
 #endif
 
 /*
@@ -147,6 +161,37 @@
              operspy);
 }
 
+static void
+ms_operspy(struct Client *client_p, struct Client *source_p,
+           int parc, char *parv[])
+{
+#ifdef OPERSPY_LOGFILE
+  FBFILE *log_fb;
+  char logfile[BUFSIZE], linebuf[BUFSIZE];
+
+  ircsprintf(logfile, "%s/operspy.remote.log", LOGPATH);
+  if ((log_fb = fbopen(logfile, "a")) == NULL)
+  {
+#ifdef OPERSPY_NOTICE
+    sendto_realops_flags(FLAGS_ADMIN, L_ALL, "Failed to open remote operspy logfile");
+#endif
+    return;
+  }
+
+  ircsprintf(linebuf, "[%s] %s -- OPERSPY %s :%s\n",
+             smalldate(CurrentTime),
+             get_oper_name(source_p),
+             parv[1], parv[2]);
+  fbputs(linebuf, log_fb);
+  fbclose(log_fb);
+#endif
+
+#ifdef OPERSPY_NOTICE
+  sendto_realops_flags(FLAGS_SPY, L_ALL, "Received OPERSPY message from %s -- %s :%s",
+                       get_oper_name(source_p), parv[1], parv[2]);
+#endif
+}
+
 /*
  * mo_operspy
  *	parv[1] = operspy command
@@ -236,6 +281,10 @@
     }
 
     sendto_one(client_p, form_str(RPL_LISTEND), me.name, client_p->name);
+
+#ifdef OPERSPY_LOG
+    operspy_log(client_p, "LIST", parv[2]);
+#endif
     return;
   }
 #endif
@@ -273,6 +322,10 @@
                me.name, parv[0], parv[2], modebuf, parabuf);
     sendto_one(client_p, form_str(RPL_CREATIONTIME),
                me.name, parv[0], parv[2], chptr_mode->channelts);
+
+#ifdef OPERSPY_LOG
+    operspy_log(client_p, "MODE", parv[2]);
+#endif
     return;
   }
 #endif
@@ -305,6 +358,10 @@
     add_user_to_channel(chptr_names, client_p, MODE_CHANOP);
     channel_member_names(client_p, chptr_names, parv[2], 1);
     remove_user_from_channel(chptr_names, client_p);
+
+#ifdef OPERSPY_LOG
+    operspy_log(client_p, "NAMES", parv[2]);
+#endif
     return;
   }
 #endif
@@ -330,6 +387,10 @@
                  parv[0], chptr_topic->chname, chptr_topic->topic_info,
                  chptr_topic->topic_time);
     }
+
+#ifdef OPERSPY_LOG
+    operspy_log(client_p, "TOPIC", parv[2]);
+#endif
     return;
   }
 #endif
@@ -350,6 +411,10 @@
     {
       who_global(client_p, NULL, server_oper);
       sendto_one(client_p, form_str(RPL_ENDOFWHO), me.name, parv[0], "*");
+
+#ifdef OPERSPY_LOG
+      log_operspy(client_p, "WHO", parv[2]);
+#endif
       return;
     }
 
@@ -361,6 +426,10 @@
         do_who_on_channel(client_p, chptr_who, chptr_who->chname, server_oper);
 
       sendto_one(client_p, form_str(RPL_ENDOFWHO), me.name, parv[0], mask);
+
+#ifdef OPERSPY_LOG
+      log_operspy(client_p, "WHO", parv[2]);
+#endif
       return;
     }
 
@@ -388,6 +457,10 @@
         do_who(client_p, target_p_who, NULL, "");
 
       sendto_one(client_p, form_str(RPL_ENDOFWHO), me.name, parv[0], mask);
+
+#ifdef OPERSPY_LOG
+      log_operspy(client_p, "WHO", parv[2]);
+#endif
       return;
     }
 
@@ -401,6 +474,9 @@
     /* nothing else? end of /who. */
     sendto_one(client_p, form_str(RPL_ENDOFWHO), me.name, parv[0], mask);
 
+#ifdef OPERSPY_LOG
+    log_operspy(client_p, "WHO", parv[2]);
+#endif
     return;
   }
 #endif
@@ -466,6 +542,10 @@
                  client_p->name, target_p->name, CurrentTime - target_p->user->last,
                  target_p->firsttime);
     sendto_one(client_p, form_str(RPL_ENDOFWHOIS), me.name, parv[0], parv[2]);
+
+#ifdef OPERSPY_LOG
+    operspy_log(client_p, "WHOIS", parv[2]);
+#endif
     return;
   }
 #endif
@@ -730,3 +810,87 @@
 #endif /* ANONOPS */
 }
 #endif /* OPERSPY_WHO */
+
+#ifdef OPERSPY_LOG
+static void
+operspy_log(struct Client *source_p, const char *command, const char *target)
+{
+  FBFILE *operspy_fb;
+  dlink_node *cnode;
+  const char *opername = source_p->name;
+  char linebuf[BUFSIZE], logfile[BUFSIZE];
+
+  assert(source_p != NULL);
+
+  if (IsOper(source_p) && MyClient(source_p))
+  {
+    DLINK_FOREACH(cnode, source_p->localClient->confs.head)
+    {
+      if (IsConfOperator((struct ConfItem *)cnode->data))
+        opername = ((struct ConfItem *)cnode->data)->name;
+    }
+  }
+
+  ircsprintf(logfile, "%s/operspy.%s.log", LOGPATH, opername);
+  if ((operspy_fb = fbopen(logfile, "a")) == NULL)
+    return;
+
+  ircsprintf(linebuf, "[%s] %s!%s@%s -- OPERSPY %s %s\n",
+             smalldate(CurrentTime),
+             get_oper_name(source_p),
+             command, target);
+  fbputs(linebuf, operspy_fb);
+  fbclose(operspy_fb);
+
+  sendto_match_servs(source_p, "*", CAP_ENCAP, "ENCAP * OPERSPY %s :%s",
+                     command, target);
+}
+#endif /* OPERSPY_LOG */
+
+static void          
+sendto_match_servs(struct Client *source_p, const char *mask, int cap,
+                   const char *pattern, ...)                         
+{
+  va_list args;
+  struct Client *target_p;
+  dlink_node *ptr;
+  char buffer[BUFSIZE];
+  int found = 0;
+    
+  va_start(args, pattern);
+  send_format(&buffer[0], IRCD_BUFSIZE, pattern, args);
+  va_end(args);
+ 
+  current_serial++;
+
+  DLINK_FOREACH(ptr, global_serv_list.head)
+  {
+    target_p = ptr->data;
+
+    /* Do not attempt to send to ourselves, or the source */
+    if (IsMe(target_p) || target_p->from == source_p->from)
+      continue;
+
+    if (target_p->from->serial == current_serial)
+      continue;
+
+    if (match(mask, target_p->name))
+    {
+      /*
+       * if we set the serial here, then we'll never do a
+       * match() again, if !IsCapable()
+       */
+      target_p->from->serial = current_serial;
+      found++;
+
+      if (!IsCapable(target_p->from, cap))
+        continue;
+                 
+      sendto_anywhere(target_p, source_p, buffer);
+    }                                             
+  }
+
+  if (!found && IsClient(source_p) && !match(mask, me.name))
+    sendto_one(source_p, form_str(ERR_NOSUCHSERVER),
+               me.name, source_p->name, mask);
+}
diff -uNr ircd-hybrid/include/parse.h ircd-hybrid+encap+olog/include/parse.h
--- ircd-hybrid/include/parse.h	Mon Jun  9 20:38:03 2003
+++ ircd-hybrid+encap+olog/include/parse.h	Mon Jun  9 20:35:10 2003
@@ -38,6 +38,7 @@
 #define MAX_MSG_HASH  387
 
 extern  void           parse (struct Client *, char *, char *);
+extern  struct Message *hash_parse(char *);
 extern  void           clear_hash_parse (void);
 extern  void           mod_add_cmd(struct Message *msg);
 extern  void           mod_del_cmd(struct Message *msg);
diff -uNr ircd-hybrid/include/s_serv.h ircd-hybrid+encap+olog/include/s_serv.h
--- ircd-hybrid/include/s_serv.h	Mon Jun  9 20:38:12 2003
+++ ircd-hybrid+encap+olog/include/s_serv.h	Mon Jun  9 20:39:37 2003
@@ -74,12 +74,13 @@
 
 #define CAP_TBURST	0x00040000   /* supports TBURST */
 #define CAP_PARA	0x00080000   /* supports invite broadcasting for +p */
+#define CAP_ENCAP	0x00100000
 
 #define CAP_MASK        (CAP_QS  | CAP_EX   | CAP_CHW  | \
                          CAP_IE  | CAP_EOB  | CAP_KLN  | \
                          CAP_GLN | CAP_HOPS | CAP_AOPS | \
                          CAP_UID | CAP_ZIP  | CAP_ENC | \
-                         CAP_KNOCK  | CAP_PARA)
+                         CAP_KNOCK  | CAP_PARA | CAP_ENCAP )
 
 #ifdef HAVE_LIBZ
 #define CAP_ZIP_SUPPORTED       CAP_ZIP
diff -uNr ircd-hybrid/modules/Makefile.in ircd-hybrid+encap+olog/modules/Makefile.in
--- ircd-hybrid/modules/Makefile.in	Sun Jun 16 11:31:25 2002
+++ ircd-hybrid+encap+olog/modules/Makefile.in	Mon Jun  9 20:39:05 2003
@@ -61,6 +61,7 @@
   m_cryptlink.c \
   m_dmem.c \
   m_drop.c \
+  m_encap.c \
   m_eob.c \
   m_gline.c \
   m_help.c \
diff -uNr ircd-hybrid/modules/m_encap.c ircd-hybrid+encap+olog/modules/m_encap.c
--- ircd-hybrid/modules/m_encap.c	Wed Dec 31 18:00:00 1969
+++ ircd-hybrid+encap+olog/modules/m_encap.c	Mon Jun  9 20:35:12 2003
@@ -0,0 +1,185 @@
+/*
+ *  ircd-hybrid: an advanced Internet Relay Chat Daemon(ircd).
+ *  m_encap.c: encapsulated command propogation and parsing
+ *
+ *  Copyright (C) 2003 by the past and present ircd coders, and others.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ *  USA
+ *
+ *  $Id: encap+olog.diff,v 1.1 2003/06/10 02:16:50 bill Exp $
+ */
+
+#include "stdinc.h"
+#include "handlers.h"
+#include "client.h"
+#include "msg.h"
+#include "parse.h"
+#include "sprintf_irc.h"
+#include "s_serv.h"
+#include "send.h"
+#include "modules.h"
+#include "irc_string.h"
+#include "common.h"
+#include "numeric.h"
+
+static void ms_encap(struct Client *client_p, struct Client *source_p,
+                     int parc, char *parv[]);
+static void sendto_match_servs(struct Client *, const char *, int, const char *, ...);
+
+struct Message encap_msgtab = {
+  "ENCAP", 0, 0, 3, 0, MFLG_SLOW, 0,
+  {m_ignore, m_ignore, ms_encap, m_ignore}
+};
+
+#ifndef STATIC_MODULES
+void
+_modinit(void)
+{
+  mod_add_cmd(&encap_msgtab);
+  add_capability("ENCAP", CAP_ENCAP, 1);
+}
+
+void
+_moddeinit(void)
+{
+  mod_del_cmd(&encap_msgtab);
+  delete_capability("ENCAP");
+}
+const char *_version = "$Revision: 1.1 $";
+#endif
+
+/*
+ * ms_encap()
+ *
+ * inputs	- destination server, subcommand, parameters
+ * outputs	- none
+ * side effects	- propogates subcommand to locally connected servers
+ */
+static void
+ms_encap(struct Client *client_p, struct Client *source_p, int parc, char *parv[])
+{
+  char buffer[BUFSIZE], *ptr = buffer;
+  unsigned int cur_len = 0, len, i;
+  int paramcount, mpara = 0;
+  struct Message *mptr = NULL;
+  MessageHandler handler = 0;
+
+  for (i = 1; i < (unsigned int)parc - 1; i++)
+  {
+    len = strlen(parv[i]) + 1;
+
+    if ((cur_len + len) >= sizeof(buffer))
+      return;
+
+    ircsprintf(ptr, "%s ", parv[i]);
+    cur_len += len;
+    ptr += len;
+  }
+
+  len = strlen(parv[i]);
+
+  /*
+   * if the final parameter crosses our buffer size, should we bail, 
+   * like the rest, or should we truncate?  ratbox seems to think truncate,
+   * so i'll do that for now until i can talk to lee.  -bill
+   */
+
+  if (parc == 3)
+    ircsprintf(ptr, "%s", parv[2]);
+  else
+    ircsprintf(ptr, ":%s", parv[parc-1]);
+
+  if ((cur_len + len) >= sizeof(buffer))
+    buffer[sizeof(buffer)-1] = '\0';
+
+  sendto_match_servs(source_p, parv[1], CAP_ENCAP,
+                     "ENCAP %s", buffer);
+
+  if (!match(parv[1], me.name))
+    return;
+
+  mptr = hash_parse(parv[2]);
+  if ((mptr == NULL) || (mptr->cmd == NULL))
+    return;
+
+  paramcount = mptr->parameters;
+  mpara      = mptr->maxpara;
+
+  mptr->bytes += strlen(buffer);
+
+  /*
+   * yes this is an ugly hack, but it is quicker than copying the entire array again
+   * note: this hack wouldnt be needed if parv[0] were set to the command name, rather
+   * than being derived from the prefix, as it should have been from the beginning.
+   */
+  ptr = parv[0];
+  parv+=2;
+  parc-=2;
+  parv[0] = ptr;
+
+  if ((handler = mptr->handlers[2]) == NULL)
+    return;
+
+  (*handler)(client_p, source_p, parc, parv);
+}
+
+static void
+sendto_match_servs(struct Client *source_p, const char *mask, int cap,
+                   const char *pattern, ...)
+{
+  va_list args;
+  struct Client *target_p;
+  dlink_node *ptr;
+  char buffer[BUFSIZE];
+  int found = 0;
+
+  va_start(args, pattern);
+  send_format(&buffer[0], IRCD_BUFSIZE, pattern, args);
+  va_end(args);
+
+  current_serial++;
+
+  DLINK_FOREACH(ptr, global_serv_list.head)
+  {
+    target_p = ptr->data;
+                         
+    /* Do not attempt to send to ourselves, or the source */
+    if (IsMe(target_p) || target_p->from == source_p->from) 
+      continue;
+
+    if (target_p->from->serial == current_serial)
+      continue;
+
+    if (match(mask, target_p->name))
+    {
+      /*
+       * if we set the serial here, then we'll never do a
+       * match() again, if !IsCapable()
+       */
+      target_p->from->serial = current_serial;
+      found++;
+
+      if (!IsCapable(target_p->from, cap))
+        continue;
+
+      sendto_anywhere(target_p, source_p, buffer);
+    }
+  }
+  
+  if (!found && IsClient(source_p) && !match(mask, me.name))
+    sendto_one(source_p, form_str(ERR_NOSUCHSERVER),
+               me.name, source_p->name, mask);
+}
diff -uNr ircd-hybrid/src/parse.c ircd-hybrid+encap+olog/src/parse.c
--- ircd-hybrid/src/parse.c	Mon Jun  9 20:38:29 2003
+++ ircd-hybrid+encap+olog/src/parse.c	Mon Jun  9 20:40:22 2003
@@ -60,7 +60,7 @@
 
 static int hash(char *p);
 
-static struct Message *hash_parse(char *);
+struct Message *hash_parse(char *);
 
 struct MessageHash *msg_hash_table[MAX_MSG_HASH];
 
@@ -498,7 +498,7 @@
  * output	- pointer to struct Message
  * side effects - 
  */
-static struct Message *
+struct Message *
 hash_parse(char *cmd)
 {
   struct MessageHash *ptr;
diff -uNr ircd-hybrid/src/s_serv.c ircd-hybrid+encap+olog/src/s_serv.c
--- ircd-hybrid/src/s_serv.c	Mon Jun  9 19:38:43 2003
+++ ircd-hybrid+encap+olog/src/s_serv.c	Mon Jun  9 21:12:33 2003
@@ -104,6 +104,7 @@
   { "ZIP",   CAP_ZIP },
   { "TBURST", CAP_TBURST },
   { "PARA",  CAP_PARA },
+  { "ENCAP", CAP_ENCAP },
   { 0,           0 }
 };
 
