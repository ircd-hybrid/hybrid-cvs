Index: ircd-hybrid/contrib/m_operspy.c
===================================================================
RCS file: /cvsroot/ircd-hybrid/contrib/m_operspy.c,v
retrieving revision 1.13.2.1
diff -u -r1.13.2.1 m_operspy.c
--- ircd-hybrid/contrib/m_operspy.c	10 Jun 2003 01:26:06 -0000	1.13.2.1
+++ ircd-hybrid/contrib/m_operspy.c	10 Jun 2003 04:25:49 -0000
@@ -55,6 +55,12 @@
 /* enable this to send incoming operspy usage to active +y (FLAGS_SPY) opers */
 #define OPERSPY_NOTICE
 
+/* enable per-oper logging of OPERSPY functions */
+#define OPERSPY_LOG
+
+/* enable this to send incoming operspy usage to active +y (FLAGS_SPY) opers */
+#define OPERSPY_NOTICE
+
 /* enable OPERSPY version of LIST */
 #define OPERSPY_LIST
 
@@ -82,6 +88,8 @@
                        int parc, char *parv[]);
 static void ms_operspy(struct Client *client_p, struct Client *source_p,
                        int parc, char *parv[]);
+static void ms_operspy(struct Client *client_p, struct Client *source_p,
+                       int parc, char *parv[]);
 static void mo_operspy(struct Client *client_p, struct Client *source_p,
                        int parc, char *parv[]);
 
@@ -190,6 +198,37 @@
 #endif
 }
 
+static void
+ms_operspy(struct Client *client_p, struct Client *source_p,
+           int parc, char *parv[])
+{
+#ifdef OPERSPY_LOGFILE
+  FBFILE *log_fb;
+  char logfile[BUFSIZE], linebuf[BUFSIZE];
+
+  ircsprintf(logfile, "%s/operspy.remote.log", LOGPATH);
+  if ((log_fb = fbopen(logfile, "a")) == NULL)
+  {
+#ifdef OPERSPY_NOTICE
+    sendto_realops_flags(FLAGS_ADMIN, L_ALL, "Failed to open remote operspy logfile");
+#endif
+    return;
+  }
+
+  ircsprintf(linebuf, "[%s] %s -- OPERSPY %s :%s\n",
+             smalldate(CurrentTime),
+             get_oper_name(source_p),
+             parv[1], parv[2]);
+  fbputs(linebuf, log_fb);
+  fbclose(log_fb);
+#endif
+
+#ifdef OPERSPY_NOTICE
+  sendto_realops_flags(FLAGS_SPY, L_ALL, "Received OPERSPY message from %s -- %s :%s",
+                       get_oper_name(source_p), parv[1], parv[2]);
+#endif
+}
+
 /*
  * mo_operspy
  *	parv[1] = operspy command
@@ -808,6 +847,90 @@
 #endif /* ANONOPS */
 }
 #endif /* OPERSPY_WHO */
+
+#ifdef OPERSPY_LOG
+static void
+operspy_log(struct Client *source_p, const char *command, const char *target)
+{
+  FBFILE *operspy_fb;
+  dlink_node *cnode;
+  const char *opername = source_p->name;
+  char linebuf[BUFSIZE], logfile[BUFSIZE];
+
+  assert(source_p != NULL);
+
+  if (IsOper(source_p) && MyClient(source_p))
+  {
+    DLINK_FOREACH(cnode, source_p->localClient->confs.head)
+    {
+      if (IsConfOperator((struct ConfItem *)cnode->data))
+        opername = ((struct ConfItem *)cnode->data)->name;
+    }
+  }
+
+  ircsprintf(logfile, "%s/operspy.%s.log", LOGPATH, opername);
+  if ((operspy_fb = fbopen(logfile, "a")) == NULL)
+    return;
+
+  ircsprintf(linebuf, "[%s] %s!%s@%s -- OPERSPY %s %s\n",
+             smalldate(CurrentTime),
+             get_oper_name(source_p),
+             command, target);
+  fbputs(linebuf, operspy_fb);
+  fbclose(operspy_fb);
+
+  sendto_match_servs(source_p, "*", CAP_ENCAP, "ENCAP * OPERSPY %s :%s",
+                     command, target);
+}
+#endif /* OPERSPY_LOG */
+
+static void          
+sendto_match_servs(struct Client *source_p, const char *mask, int cap,
+                   const char *pattern, ...)                         
+{
+  va_list args;
+  struct Client *target_p;
+  dlink_node *ptr;
+  char buffer[BUFSIZE];
+  int found = 0;
+    
+  va_start(args, pattern);
+  send_format(&buffer[0], IRCD_BUFSIZE, pattern, args);
+  va_end(args);
+ 
+  current_serial++;
+
+  DLINK_FOREACH(ptr, global_serv_list.head)
+  {
+    target_p = ptr->data;
+
+    /* Do not attempt to send to ourselves, or the source */
+    if (IsMe(target_p) || target_p->from == source_p->from)
+      continue;
+
+    if (target_p->from->serial == current_serial)
+      continue;
+
+    if (match(mask, target_p->name))
+    {
+      /*
+       * if we set the serial here, then we'll never do a
+       * match() again, if !IsCapable()
+       */
+      target_p->from->serial = current_serial;
+      found++;
+
+      if (!IsCapable(target_p->from, cap))
+        continue;
+                 
+      sendto_anywhere(target_p, source_p, buffer);
+    }                                             
+  }
+
+  if (!found && IsClient(source_p) && !match(mask, me.name))
+    sendto_one(source_p, form_str(ERR_NOSUCHSERVER),
+               me.name, source_p->name, mask);
+}
 
 #ifdef OPERSPY_LOG
 static void
Index: ircd-hybrid/include/parse.h
===================================================================
RCS file: /cvsroot/ircd-hybrid/include/parse.h,v
retrieving revision 7.15.2.2
diff -u -r7.15.2.2 parse.h
--- ircd-hybrid/include/parse.h	10 Jun 2003 02:16:52 -0000	7.15.2.2
+++ ircd-hybrid/include/parse.h	10 Jun 2003 04:25:50 -0000
@@ -38,6 +38,7 @@
 #define MAX_MSG_HASH  387
 
 extern  void           parse (struct Client *, char *, char *);
+extern  struct Message *hash_parse(char *);
 extern  void           clear_hash_parse (void);
 extern  void           mod_add_cmd(struct Message *msg);
 extern  void           mod_del_cmd(struct Message *msg);
Index: ircd-hybrid/include/s_serv.h
===================================================================
RCS file: /cvsroot/ircd-hybrid/include/s_serv.h,v
retrieving revision 7.66.4.3
diff -u -r7.66.4.3 s_serv.h
--- ircd-hybrid/include/s_serv.h	10 Jun 2003 02:16:52 -0000	7.66.4.3
+++ ircd-hybrid/include/s_serv.h	10 Jun 2003 04:25:50 -0000
@@ -74,12 +74,13 @@
 
 #define CAP_TBURST	0x00040000   /* supports TBURST */
 #define CAP_PARA	0x00080000   /* supports invite broadcasting for +p */
+#define CAP_ENCAP	0x00100000
 
 #define CAP_MASK        (CAP_QS  | CAP_EX   | CAP_CHW  | \
                          CAP_IE  | CAP_EOB  | CAP_KLN  | \
                          CAP_GLN | CAP_HOPS | CAP_AOPS | \
                          CAP_UID | CAP_ZIP  | CAP_ENC | \
-                         CAP_KNOCK  | CAP_PARA)
+                         CAP_KNOCK  | CAP_PARA | CAP_ENCAP )
 
 #ifdef HAVE_LIBZ
 #define CAP_ZIP_SUPPORTED       CAP_ZIP
Index: ircd-hybrid/modules/Makefile.in
===================================================================
RCS file: /cvsroot/ircd-hybrid/modules/Makefile.in,v
retrieving revision 1.69
diff -u -r1.69 Makefile.in
--- ircd-hybrid/modules/Makefile.in	16 Jun 2002 16:31:25 -0000	1.69
+++ ircd-hybrid/modules/Makefile.in	10 Jun 2003 04:25:50 -0000
@@ -61,6 +61,7 @@
   m_cryptlink.c \
   m_dmem.c \
   m_drop.c \
+  m_encap.c \
   m_eob.c \
   m_gline.c \
   m_help.c \
Index: ircd-hybrid/src/parse.c
===================================================================
RCS file: /cvsroot/ircd-hybrid/src/parse.c,v
retrieving revision 7.146.2.2
diff -u -r7.146.2.2 parse.c
--- ircd-hybrid/src/parse.c	10 Jun 2003 02:16:54 -0000	7.146.2.2
+++ ircd-hybrid/src/parse.c	10 Jun 2003 04:25:50 -0000
@@ -60,7 +60,7 @@
 
 static int hash(char *p);
 
-static struct Message *hash_parse(char *);
+struct Message *hash_parse(char *);
 
 struct MessageHash *msg_hash_table[MAX_MSG_HASH];
 
@@ -498,7 +498,7 @@
  * output	- pointer to struct Message
  * side effects - 
  */
-static struct Message *
+struct Message *
 hash_parse(char *cmd)
 {
   struct MessageHash *ptr;
Index: ircd-hybrid/src/s_serv.c
===================================================================
RCS file: /cvsroot/ircd-hybrid/src/s_serv.c,v
retrieving revision 7.280.2.3
diff -u -r7.280.2.3 s_serv.c
--- ircd-hybrid/src/s_serv.c	31 May 2003 07:30:34 -0000	7.280.2.3
+++ ircd-hybrid/src/s_serv.c	10 Jun 2003 04:25:51 -0000
@@ -104,6 +104,7 @@
   { "ZIP",   CAP_ZIP },
   { "TBURST", CAP_TBURST },
   { "PARA",  CAP_PARA },
+  { "ENCAP", CAP_ENCAP },
   { 0,           0 }
 };
 
--- /dev/null	Tue Jun 10 00:18:25 2003
+++ ircd-hybrid/modules/m_encap.c	Tue Jun 10 00:24:20 2003
@@ -0,0 +1,185 @@
+/*
+ *  ircd-hybrid: an advanced Internet Relay Chat Daemon(ircd).
+ *  m_encap.c: encapsulated command propogation and parsing
+ *
+ *  Copyright (C) 2003 by the past and present ircd coders, and others.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ *  USA
+ *
+ *  $Id: encap+olog.diff,v 1.2.2.2 2003/06/10 04:29:58 db Exp $
+ */
+
+#include "stdinc.h"
+#include "handlers.h"
+#include "client.h"
+#include "msg.h"
+#include "parse.h"
+#include "sprintf_irc.h"
+#include "s_serv.h"
+#include "send.h"
+#include "modules.h"
+#include "irc_string.h"
+#include "common.h"
+#include "numeric.h"
+
+static void ms_encap(struct Client *client_p, struct Client *source_p,
+                     int parc, char *parv[]);
+static void sendto_match_servs(struct Client *, const char *, int, const char *, ...);
+
+struct Message encap_msgtab = {
+  "ENCAP", 0, 0, 3, 0, MFLG_SLOW, 0,
+  {m_ignore, m_ignore, ms_encap, m_ignore}
+};
+
+#ifndef STATIC_MODULES
+void
+_modinit(void)
+{
+  mod_add_cmd(&encap_msgtab);
+  add_capability("ENCAP", CAP_ENCAP, 1);
+}
+
+void
+_moddeinit(void)
+{
+  mod_del_cmd(&encap_msgtab);
+  delete_capability("ENCAP");
+}
+const char *_version = "$Revision: 1.2.2.2 $";
+#endif
+
+/*
+ * ms_encap()
+ *
+ * inputs	- destination server, subcommand, parameters
+ * outputs	- none
+ * side effects	- propogates subcommand to locally connected servers
+ */
+static void
+ms_encap(struct Client *client_p, struct Client *source_p, int parc, char *parv[])
+{
+  char buffer[BUFSIZE], *ptr = buffer;
+  unsigned int cur_len = 0, len, i;
+  int paramcount, mpara = 0;
+  struct Message *mptr = NULL;
+  MessageHandler handler = 0;
+
+  for (i = 1; i < (unsigned int)parc - 1; i++)
+  {
+    len = strlen(parv[i]) + 1;
+
+    if ((cur_len + len) >= sizeof(buffer))
+      return;
+
+    ircsprintf(ptr, "%s ", parv[i]);
+    cur_len += len;
+    ptr += len;
+  }
+
+  len = strlen(parv[i]);
+
+  /*
+   * if the final parameter crosses our buffer size, should we bail, 
+   * like the rest, or should we truncate?  ratbox seems to think truncate,
+   * so i'll do that for now until i can talk to lee.  -bill
+   */
+
+  if (parc == 3)
+    ircsprintf(ptr, "%s", parv[2]);
+  else
+    ircsprintf(ptr, ":%s", parv[parc-1]);
+
+  if ((cur_len + len) >= sizeof(buffer))
+    buffer[sizeof(buffer)-1] = '\0';
+
+  sendto_match_servs(source_p, parv[1], CAP_ENCAP,
+                     "ENCAP %s", buffer);
+
+  if (!match(parv[1], me.name))
+    return;
+
+  mptr = hash_parse(parv[2]);
+  if ((mptr == NULL) || (mptr->cmd == NULL))
+    return;
+
+  paramcount = mptr->parameters;
+  mpara      = mptr->maxpara;
+
+  mptr->bytes += strlen(buffer);
+
+  /*
+   * yes this is an ugly hack, but it is quicker than copying the entire array again
+   * note: this hack wouldnt be needed if parv[0] were set to the command name, rather
+   * than being derived from the prefix, as it should have been from the beginning.
+   */
+  ptr = parv[0];
+  parv+=2;
+  parc-=2;
+  parv[0] = ptr;
+
+  if ((handler = mptr->handlers[2]) == NULL)
+    return;
+
+  (*handler)(client_p, source_p, parc, parv);
+}
+
+static void
+sendto_match_servs(struct Client *source_p, const char *mask, int cap,
+                   const char *pattern, ...)
+{
+  va_list args;
+  struct Client *target_p;
+  dlink_node *ptr;
+  char buffer[BUFSIZE];
+  int found = 0;
+
+  va_start(args, pattern);
+  send_format(&buffer[0], IRCD_BUFSIZE, pattern, args);
+  va_end(args);
+
+  current_serial++;
+
+  DLINK_FOREACH(ptr, global_serv_list.head)
+  {
+    target_p = ptr->data;
+                         
+    /* Do not attempt to send to ourselves, or the source */
+    if (IsMe(target_p) || target_p->from == source_p->from) 
+      continue;
+
+    if (target_p->from->serial == current_serial)
+      continue;
+
+    if (match(mask, target_p->name))
+    {
+      /*
+       * if we set the serial here, then we'll never do a
+       * match() again, if !IsCapable()
+       */
+      target_p->from->serial = current_serial;
+      found++;
+
+      if (!IsCapable(target_p->from, cap))
+        continue;
+
+      sendto_anywhere(target_p, source_p, buffer);
+    }
+  }
+  
+  if (!found && IsClient(source_p) && !match(mask, me.name))
+    sendto_one(source_p, form_str(ERR_NOSUCHSERVER),
+               me.name, source_p->name, mask);
+}
