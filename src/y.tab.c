/*  $Id: y.tab.c,v 7.21.2.1 2005/07/22 17:21:02 db Exp $ */
#include <stdlib.h>
#ifndef lint
#ifdef __unused
__unused
#endif
static char const 
yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.37 2003/02/12 18:03:55 davidc Exp $";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYLEX yylex()
#define YYEMPTY -1
#define yyclearin (yychar=(YYEMPTY))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING() (yyerrflag!=0)
#if defined(__cplusplus) || __STDC__
static int yygrowstack(void);
#else
static int yygrowstack();
#endif
#define YYPREFIX "yy"
#line 26 "ircd_parser.y"

/* XXX */
#define WE_ARE_MEMORY_C

#define YY_NO_UNPUT
#include "stdinc.h"
#include "dalloca.h"
#include "ircd.h"
#include "tools.h"
#include "list.h"
#include "s_conf.h"
#include "event.h"
#include "s_log.h"
#include "client.h"	/* for UMODE_ALL only */
#include "irc_string.h"
#include "irc_getaddrinfo.h"
#include "ircdauth.h"
#include "memory.h"
#include "modules.h"
#include "s_serv.h" /* for CAP_LL / IsCapable */
#include "hostmask.h"
#include "send.h"
#include "listener.h"
#include "resv.h"
#include "numeric.h"
#include "cluster.h"
#include "s_user.h"

#ifdef HAVE_LIBCRYPTO
#include <openssl/rsa.h>
#include <openssl/bio.h>
#include <openssl/pem.h>
#endif

static char *class_name = NULL;
static struct ConfItem *yy_conf = NULL;
static struct AccessItem *yy_aconf = NULL;
static struct MatchItem *yy_match_item = NULL;
static struct ClassItem *yy_class = NULL;

static dlink_list col_conf_list  = { NULL, NULL, 0 };
static dlink_list hub_conf_list  = { NULL, NULL, 0 };
static dlink_list leaf_conf_list = { NULL, NULL, 0 };

extern dlink_list gdeny_items;

static char *resv_reason;
static char *listener_address;
static int not_atom = 0;

struct CollectItem {
  dlink_node node;
  char *name;
  char *user;
  char *host;
  char *passwd;
  int  port;
  int  flags;
#ifdef HAVE_LIBCRYPTO
  char *rsa_public_key_file;
  RSA *rsa_public_key;
#endif
};

static void
free_collect_item(struct CollectItem *item)
{
  MyFree(item->name);
  MyFree(item->user);
  MyFree(item->host);
  MyFree(item->passwd);
#ifdef HAVE_LIBCRYPTO
  MyFree(item->rsa_public_key_file);
#endif
  MyFree(item);
}

static void
unhook_hub_leaf_confs(void)
{
  dlink_node *ptr;
  dlink_node *next_ptr;
  struct CollectItem *yy_hconf;
  struct CollectItem *yy_lconf;

  DLINK_FOREACH_SAFE(ptr, next_ptr, hub_conf_list.head)
  {
    yy_hconf = ptr->data;
    dlinkDelete(&yy_hconf->node, &hub_conf_list);
    free_collect_item(yy_hconf);
  }

  DLINK_FOREACH_SAFE(ptr, next_ptr, leaf_conf_list.head)
  {
    yy_lconf = ptr->data;
    dlinkDelete(&yy_lconf->node, &leaf_conf_list);
    free_collect_item(yy_lconf);
  }
}

#line 128 "ircd_parser.y"
typedef union {
  int number;
  char *string;
} YYSTYPE;
#line 130 "y.tab.c"
#define YYERRCODE 256
#define ACCEPT_PASSWORD 257
#define ACTION 258
#define ADMIN 259
#define AFTYPE 260
#define T_ALLOW 261
#define ANTI_NICK_FLOOD 262
#define ANTI_SPAM_EXIT_MESSAGE_TIME 263
#define IRCD_AUTH 264
#define AUTOCONN 265
#define T_BLOCK 266
#define BURST_AWAY 267
#define BYTES 268
#define KBYTES 269
#define MBYTES 270
#define GBYTES 271
#define TBYTES 272
#define CALLER_ID_WAIT 273
#define CAN_FLOOD 274
#define CAN_IDLE 275
#define CHANNEL 276
#define CIPHER_PREFERENCE 277
#define CLASS 278
#define COMPRESSED 279
#define COMPRESSION_LEVEL 280
#define CONNECT 281
#define CONNECTFREQ 282
#define CRYPTLINK 283
#define DEFAULT_CIPHER_PREFERENCE 284
#define DEFAULT_FLOODCOUNT 285
#define DEFAULT_SPLIT_SERVER_COUNT 286
#define DEFAULT_SPLIT_USER_COUNT 287
#define DENY 288
#define DESCRIPTION 289
#define DIE 290
#define DISABLE_AUTH 291
#define DISABLE_HIDDEN 292
#define DISABLE_LOCAL_CHANNELS 293
#define DISABLE_REMOTE_COMMANDS 294
#define DOT_IN_IP6_ADDR 295
#define DOTS_IN_IDENT 296
#define DURATION 297
#define EGDPOOL_PATH 298
#define EMAIL 299
#define ENABLE 300
#define ENCRYPTED 301
#define EXCEED_LIMIT 302
#define EXEMPT 303
#define FAILED_OPER_NOTICE 304
#define FAKENAME 305
#define IRCD_FLAGS 306
#define FLATTEN_LINKS 307
#define FFAILED_OPERLOG 308
#define FOPERLOG 309
#define FUSERLOG 310
#define GECOS 311
#define GENERAL 312
#define GLINE 313
#define GLINES 314
#define GLINE_EXEMPT 315
#define GLINE_LOG 316
#define GLINE_TIME 317
#define GLINE_MIN_CIDR 318
#define GLINE_MIN_CIDR6 319
#define GLOBAL_KILL 320
#define NEED_IDENT 321
#define HAVENT_READ_CONF 322
#define HIDDEN 323
#define HIDDEN_ADMIN 324
#define HIDDEN_OPER 325
#define HIDE_SERVER_IPS 326
#define HIDE_SERVERS 327
#define HIDE_SPOOF_IPS 328
#define HOST 329
#define HUB 330
#define HUB_MASK 331
#define IDLETIME 332
#define IGNORE_BOGUS_TS 333
#define IP 334
#define KILL 335
#define KILL_CHASE_TIME_LIMIT 336
#define KLINE 337
#define KLINE_EXEMPT 338
#define KLINE_REASON 339
#define KLINE_WITH_REASON 340
#define KNOCK_DELAY 341
#define KNOCK_DELAY_CHANNEL 342
#define LAZYLINK 343
#define LEAF_MASK 344
#define LINKS_DELAY 345
#define LISTEN 346
#define LOGGING 347
#define LOG_LEVEL 348
#define MAXIMUM_LINKS 349
#define MAX_ACCEPT 350
#define MAX_BANS 351
#define MAX_CHANS_PER_USER 352
#define MAX_GLOBAL 353
#define MAX_IDENT 354
#define MAX_LOCAL 355
#define MAX_NICK_CHANGES 356
#define MAX_NICK_TIME 357
#define MAX_NUMBER 358
#define MAX_TARGETS 359
#define MESSAGE_LOCALE 360
#define MIN_NONWILDCARD 361
#define MIN_NONWILDCARD_SIMPLE 362
#define MODULE 363
#define MODULES 364
#define NAME 365
#define NEED_PASSWORD 366
#define NETWORK_DESC 367
#define NETWORK_NAME 368
#define NICK 369
#define NICK_CHANGES 370
#define NO_CREATE_ON_SPLIT 371
#define NO_JOIN_ON_SPLIT 372
#define NO_OPER_FLOOD 373
#define NO_TILDE 374
#define NOT 375
#define NUMBER 376
#define NUMBER_PER_IDENT 377
#define NUMBER_PER_IP 378
#define NUMBER_PER_IP_GLOBAL 379
#define OPERATOR 380
#define OPER_LOG 381
#define OPER_ONLY_UMODES 382
#define OPER_PASS_RESV 383
#define OPER_SPY_T 384
#define OPER_UMODES 385
#define INVITE_OPS_ONLY 386
#define PACE_WAIT 387
#define PACE_WAIT_SIMPLE 388
#define PASSWORD 389
#define PATH 390
#define PING_COOKIE 391
#define PING_TIME 392
#define PORT 393
#define QSTRING 394
#define QUIET_ON_BAN 395
#define REASON 396
#define REDIRPORT 397
#define REDIRSERV 398
#define REHASH 399
#define REMOTE 400
#define REMOTEBAN 401
#define RESTRICTED 402
#define RSA_PRIVATE_KEY_FILE 403
#define RSA_PUBLIC_KEY_FILE 404
#define RESV 405
#define RESV_EXEMPT 406
#define SECONDS 407
#define MINUTES 408
#define HOURS 409
#define DAYS 410
#define WEEKS 411
#define SENDQ 412
#define SEND_PASSWORD 413
#define SERVERHIDE 414
#define SERVERINFO 415
#define SERVLINK_PATH 416
#define SID 417
#define TKLINE_EXPIRE_NOTICES 418
#define T_SHARED 419
#define T_CLUSTER 420
#define TYPE 421
#define SHORT_MOTD 422
#define SILENT 423
#define SPOOF 424
#define SPOOF_NOTICE 425
#define STATS_I_OPER_ONLY 426
#define STATS_K_OPER_ONLY 427
#define STATS_O_OPER_ONLY 428
#define STATS_P_OPER_ONLY 429
#define TBOOL 430
#define TMASKED 431
#define T_REJECT 432
#define TS_MAX_DELTA 433
#define TS_WARN_DELTA 434
#define TWODOTS 435
#define T_ALL 436
#define T_BOTS 437
#define T_CALLERID 438
#define T_CCONN 439
#define T_CLIENT_FLOOD 440
#define T_DEBUG 441
#define T_DRONE 442
#define T_EXTERNAL 443
#define T_FULL 444
#define T_INVISIBLE 445
#define T_IPV4 446
#define T_IPV6 447
#define T_LOCOPS 448
#define T_LOGPATH 449
#define T_L_CRIT 450
#define T_L_DEBUG 451
#define T_L_ERROR 452
#define T_L_INFO 453
#define T_L_NOTICE 454
#define T_L_TRACE 455
#define T_L_WARN 456
#define T_MAX_CLIENTS 457
#define T_NCHANGE 458
#define T_OPERWALL 459
#define T_REJ 460
#define T_SERVNOTICE 461
#define T_SKILL 462
#define T_SPY 463
#define T_UNAUTH 464
#define T_UNRESV 465
#define T_UNXLINE 466
#define T_WALLOP 467
#define THROTTLE_TIME 468
#define TRUE_NO_OPER_FLOOD 469
#define UNKLINE 470
#define USER 471
#define USE_EGD 472
#define USE_EXCEPT 473
#define USE_INVEX 474
#define USE_KNOCK 475
#define USE_LOGGING 476
#define VHOST 477
#define VHOST6 478
#define XLINE 479
#define WARN 480
#define WARN_NO_NLINE 481
const short yylhs[] = {                                        -1,
    0,    0,    5,    5,    5,    5,    5,    5,    5,    5,
    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
    5,    5,    5,    5,    2,    2,    1,    1,    1,    1,
    1,    1,    4,    4,    3,    3,    3,    3,   25,   26,
   26,   27,   27,   27,   28,   29,   13,   30,   30,   31,
   31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
   39,   32,   41,   35,   36,   37,   33,   40,   38,   34,
    6,   42,   42,   43,   43,   43,   43,   44,   46,   45,
    7,   47,   47,   48,   48,   48,   48,   48,   48,   48,
   48,   48,   49,   50,   51,   54,   56,   55,   52,   52,
   52,   52,   52,   52,   52,   53,   58,    8,   57,   57,
   59,   59,   61,   61,   61,   61,   61,   61,   61,   61,
   61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
   61,   62,   60,   63,   64,   77,   65,   78,   66,   67,
   68,   69,   70,   71,   72,   73,   74,   75,   76,   80,
   79,   81,   81,   82,   82,   83,   83,   83,   83,   83,
   83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
   85,   10,   84,   84,   86,   86,   88,   88,   88,   88,
   88,   88,   88,   88,   88,   88,   89,   87,   90,   91,
   92,   93,   94,   95,   96,   97,   98,   11,   99,   99,
  100,  100,  100,  100,  101,  104,  104,  105,  105,  102,
  103,  106,   12,  107,  107,  108,  108,  108,  108,  108,
  108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
  108,  109,  110,  119,  111,  124,  112,  125,  125,  126,
  126,  127,  127,  127,  127,  127,  127,  127,  127,  127,
  127,  113,  114,  115,  122,  116,  117,  118,  120,  121,
  123,  128,   15,  129,  129,  130,  130,  130,  130,  131,
  132,  133,  134,   16,  135,  135,  136,  136,  136,  136,
  137,  138,  140,  139,  141,  141,  142,  142,  142,  142,
  142,  142,  142,  143,   17,  144,  144,  145,  145,  145,
  146,  148,  147,  149,  149,  150,  150,  150,  150,  150,
  150,  150,  150,  152,   18,  151,  151,  153,  153,  155,
  155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
  155,  155,  155,  155,  155,  155,  155,  156,  154,  157,
  158,  159,  160,  161,  161,  162,  173,  163,  174,  174,
  175,  175,  175,  175,  175,  171,  168,  170,  169,  167,
  164,  165,  166,  172,  176,   19,  177,  177,  178,  178,
  178,  179,  180,  181,   20,  182,  182,  183,  183,  183,
  184,  185,  186,   21,  187,  187,  188,  188,  189,  190,
   24,  191,  191,  192,  192,  192,  193,  194,   22,  195,
  195,  196,  196,  196,  196,  196,  196,  196,  196,  196,
  196,  196,  196,  196,  196,  196,  196,  196,  196,  196,
  196,  196,  196,  196,  196,  196,  196,  196,  196,  196,
  196,  196,  196,  196,  196,  196,  196,  196,  196,  196,
  196,  196,  196,  196,  196,  196,  196,  196,  196,  196,
  196,  196,  196,  246,  247,  244,  245,  207,  197,  198,
  235,  199,  200,  201,  202,  203,  204,  205,  206,  240,
  208,  209,  210,  212,  217,  213,  213,  215,  215,  214,
  230,  216,  218,  219,  220,  221,  224,  222,  211,  223,
  226,  234,  236,  237,  227,  228,  242,  243,  239,  248,
  229,  249,  249,  250,  250,  250,  250,  250,  250,  250,
  250,  250,  250,  250,  250,  250,  250,  250,  250,  251,
  225,  252,  252,  253,  253,  253,  253,  253,  253,  253,
  253,  253,  253,  253,  253,  253,  253,  253,  253,  232,
  233,  231,  238,  241,  254,   23,  255,  255,  256,  256,
  256,  256,  256,  256,  256,  257,  258,  263,  259,  264,
  264,  265,  265,  260,  261,  266,  262,  267,  267,  268,
  268,    9,  269,  269,  270,  270,  270,  270,  270,  270,
  270,  270,  270,  270,  270,  270,  270,  270,  270,  271,
  272,  273,  274,  276,  277,  278,  279,  280,  275,  281,
  282,  283,  284,   14,  285,  285,  286,  286,  286,  286,
  286,  286,  286,  287,  288,  289,  291,  290,  292,
};
const short yylen[] = {                                         2,
    0,    2,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    2,    2,    0,    1,    2,    3,    3,    3,
    3,    3,    0,    1,    2,    3,    3,    3,    5,    2,
    1,    1,    1,    1,    4,    4,    5,    2,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    5,    2,    1,    1,    1,    1,    1,    4,    4,    4,
    5,    2,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    0,    7,    0,    1,
    2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    4,    1,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    0,
    5,    3,    1,    2,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    0,    7,    0,    1,    2,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    4,    1,    4,    4,
    4,    4,    4,    4,    4,    4,    0,    6,    2,    1,
    1,    1,    1,    1,    4,    3,    1,    1,    3,    4,
    4,    0,    6,    2,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    4,    4,    4,    4,    0,    5,    3,    1,    2,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    0,    6,    2,    1,    1,    1,    1,    1,    4,
    4,    4,    0,    6,    2,    1,    1,    1,    1,    1,
    4,    4,    0,    5,    3,    1,    1,    1,    1,    1,
    1,    1,    1,    0,    6,    2,    1,    1,    1,    1,
    4,    0,    5,    3,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    0,    7,    0,    1,    2,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    4,    1,    4,
    4,    4,    4,    4,    4,    4,    0,    5,    3,    1,
    1,    1,    1,    1,    1,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    0,    6,    2,    1,    1,    1,
    1,    4,    4,    0,    6,    2,    1,    1,    1,    1,
    4,    4,    0,    6,    2,    1,    1,    1,    4,    0,
    6,    2,    1,    1,    1,    1,    4,    4,    5,    2,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    0,
    5,    3,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    0,
    5,    3,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    4,
    4,    4,    4,    4,    0,    6,    2,    1,    1,    1,
    1,    1,    1,    1,    1,    4,    4,    0,    5,    3,
    1,    1,    1,    4,    4,    0,    5,    3,    1,    1,
    1,    5,    2,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    5,    2,    1,    1,    1,    1,    1,
    1,    1,    1,    4,    4,    4,    4,    4,    4,
};
const short yydefred[] = {                                      1,
    0,    0,    0,  212,    0,  171,  314,  374,  383,  390,
    0,  545,  365,  197,    0,    0,  107,  262,    0,    0,
  273,  294,    2,    3,    4,    5,    6,    7,    8,    9,
   10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
   20,   21,   22,   23,   24,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   77,    0,    0,    0,    0,
   73,   74,   75,   76,    0,  589,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  574,  575,  576,  577,  578,  579,  580,  581,  582,
  583,  584,  585,  586,  587,  588,  188,    0,  174,  339,
    0,  317,    0,    0,    0,  453,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  520,    0,  500,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  401,  402,
  403,  404,  405,  406,  407,  408,  409,  410,  411,  412,
  413,  414,  415,  416,  417,  418,  419,  420,  421,  422,
  423,  424,  425,  426,  427,  428,  429,  430,  431,  432,
  433,  434,  435,  436,  437,  438,  439,  440,  441,  442,
  443,  444,  445,  446,  447,  448,  449,  450,  451,  452,
    0,    0,    0,   92,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   83,   84,   85,   86,   87,   88,   89,
   90,   91,   44,    0,    0,    0,   41,   42,   43,  133,
    0,  110,    0,  613,    0,    0,    0,    0,    0,    0,
    0,  606,  607,  608,  609,  610,  611,  612,   60,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   49,   50,   51,   52,   53,   54,   55,   56,   57,   58,
   59,    0,    0,    0,    0,    0,    0,   72,  231,    0,
    0,    0,  236,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  215,  216,  217,  218,  219,
  220,  221,  222,  223,  224,  225,  226,  227,  228,  229,
  230,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  573,    0,    0,  380,
    0,    0,    0,  377,  378,  379,  388,    0,    0,  386,
  387,  396,    0,    0,    0,  393,  394,  395,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  400,  555,  566,    0,    0,  558,    0,    0,    0,  548,
  549,  550,  551,  552,  553,  554,  371,    0,    0,    0,
  368,  369,  370,  204,    0,    0,    0,    0,  200,  201,
  202,  203,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   82,    0,    0,    0,   40,    0,  269,    0,    0,
    0,    0,  265,  266,  267,  268,    0,    0,    0,    0,
    0,    0,    0,  605,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   48,  280,    0,  283,    0,
    0,  276,  277,  278,  279,  300,    0,  302,    0,  297,
  298,  299,    0,    0,    0,   71,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  214,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  572,  186,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  176,  177,  178,  179,  180,  181,  182,  183,  184,  185,
  337,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  347,    0,    0,    0,    0,    0,    0,    0,    0,  319,
  320,  321,  322,  323,  324,  325,  326,  327,  328,  329,
  330,  331,  332,  333,  334,  335,  336,    0,    0,    0,
  376,    0,    0,  385,    0,    0,    0,  392,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  399,    0,    0,    0,    0,    0,    0,    0,
  547,    0,    0,    0,  367,    0,    0,    0,    0,  199,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   81,    0,    0,   39,  131,    0,
    0,    0,    0,  150,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  112,  113,
  114,  115,  116,  117,  118,  119,  120,  121,  122,  123,
  124,  125,  126,  127,  128,  129,  130,    0,    0,    0,
    0,  264,    0,    0,    0,    0,    0,    0,  604,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   47,
    0,    0,    0,    0,  275,    0,    0,    0,  296,   80,
   79,   78,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  213,  601,  600,
  590,    0,    0,    0,    0,    0,   26,   27,  594,  595,
  599,  597,  602,  603,  596,  598,  591,  592,  593,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  175,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  318,    0,
    0,  375,    0,  384,    0,    0,  391,  463,  467,  456,
  481,  494,  493,  542,  498,  461,  544,  489,  496,  462,
  454,  455,  470,  459,  488,  460,  458,  472,  471,  490,
  466,  465,  464,  491,  487,  540,  541,  484,  524,  538,
  525,  526,  533,  527,  536,  539,  529,  534,  530,  535,
  528,  532,  531,  537,    0,  523,  486,  504,  518,  505,
  506,  513,  507,  516,  519,  509,  514,  510,  515,  508,
  512,  511,  517,    0,  503,  480,  482,  497,  492,  457,
  483,  478,  479,  476,  477,  474,  475,  469,  468,    0,
    0,    0,   34,   35,  543,  499,  485,  495,  473,    0,
    0,    0,    0,    0,    0,  546,    0,    0,  366,    0,
    0,    0,    0,  207,  198,   97,   98,   96,   95,   99,
  105,  100,  104,  102,  103,  101,   94,   93,  106,   45,
   46,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  111,    0,    0,    0,  263,  618,  614,  617,  619,  615,
  616,   64,   70,   62,   66,   65,   61,   63,   69,   67,
   68,    0,    0,    0,  274,    0,    0,  295,  255,  235,
  254,  246,  247,  243,  249,  245,  244,  251,  248,    0,
  250,  242,    0,  239,  241,  257,  253,  252,  261,  256,
  233,  260,  259,  258,  234,  232,   28,   29,   30,   31,
   32,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  172,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  315,
  381,  382,  389,  397,  398,  521,    0,  501,    0,   36,
   37,   38,  571,  570,    0,  569,  557,  556,  563,  562,
    0,  561,  565,  564,  373,  372,  211,  210,    0,  205,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  108,
  271,  272,  270,  281,  287,  291,  293,  292,  290,  288,
  289,    0,  286,  282,  301,  306,  310,  313,  312,  311,
  309,  307,  308,    0,  305,  240,  237,    0,  191,  193,
  195,  194,  192,  187,  190,  189,  196,  342,  344,  345,
  360,  364,  363,  359,  358,  357,  346,  354,  355,  352,
  353,  351,    0,  350,  340,  361,  362,  338,  343,  356,
  341,  522,  502,  567,    0,  559,    0,  209,  206,  149,
  139,  147,  136,  164,  162,  161,  156,  165,  169,  158,
  166,    0,  168,  163,  157,  170,  167,  159,  160,    0,
  153,  155,  145,  140,  137,  142,  132,  146,  135,  148,
  141,  138,  144,  134,  143,  284,    0,  303,    0,  238,
  348,    0,  568,  560,  154,  151,    0,  285,  304,  349,
  152,
};
const short yydgoto[] = {                                       1,
  807,  808,  943,  944,   23,   24,   25,   26,   27,   28,
   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,
   39,   40,   41,   42,   43,  246,  247,  248,  249,  280,
  281,  282,  283,  284,  285,  286,  287,  288,  289,  290,
  291,   70,   71,   72,   73,   74,  233,  234,  235,  236,
  237,  238,  239,  240,  241,  242,  251,   60,  728,  252,
  729,  730,  731,  732,  733,  734,  735,  736,  737,  738,
  739,  740,  741,  742,  743,  744,  745,  746,  747,  986,
 1230, 1231, 1232,  108,   49,  560,  109,  561,  562,  563,
  564,  565,  566,  567,  568,  569,  570,   57,  448,  449,
  450,  451,  452,  963,  964,   47,  315,  316,  317,  318,
  319,  320,  321,  322,  323,  324,  325,  326,  327,  328,
  329,  330,  331,  520, 1043, 1044, 1045,   61,  472,  473,
  474,  475,  476,   64,  501,  502,  503,  504,  505,  772,
 1152, 1153,   65,  509,  510,  511,  512,  777, 1164, 1165,
  111,   50,  589,  112,  590,  591,  592,  593,  594,  595,
  596,  597,  598,  599,  600,  601,  602,  603,  604,  605,
  606,  607,  840, 1193, 1194,   56,  440,  441,  442,  443,
   51,  353,  354,  355,  356,   52,  359,  360,  361,   53,
  365,  366,  367,  368,  168,  169,  170,  171,  172,  173,
  174,  175,  176,  177,  178,  179,  180,  181,  182,  183,
  184,  185,  186,  187,  188,  189,  190,  191,  192,  193,
  194,  195,  196,  197,  198,  199,  200,  201,  202,  203,
  204,  205,  206,  207,  208,  209,  210,  211,  212,  213,
  214,  215,  216,  217,  218,  219,  220,  402,  924,  925,
  400,  905,  906,   55,  429,  430,  431,  432,  433,  434,
  435,  436,  677, 1111, 1112,  674, 1105, 1106,   91,   92,
   93,   94,   95,   96,   97,   98,   99,  100,  101,  102,
  103,  104,  105,  106,  261,  262,  263,  264,  265,  266,
  267,  268,
};
const short yysindex[] = {                                      0,
  546,  -27,  -96,    0,  -94,    0,    0,    0,    0,    0,
  -89,    0,    0,    0,  -87,  -80,    0,    0,  -69,  -66,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0, -206,  -57,  362, -363, -319,
  -43,  -41,  -36,  249,  -33,  -20,  -15, -191, -211, -281,
   -8, -231,  135,    1,   54,    0,   70,  104,  117, -108,
    0,    0,    0,    0,  482,    0,  122,  123,  126,  128,
  131,  132,  133,  134,  138,  143,  146,  151,  154,  159,
   46,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   75,    0,    0,
   98,    0, -246, -248, -226,    0,  162,  165,  169,  171,
  185,  186,  189,  198,  203,  207,  209,  210,  219,  220,
  221,  227,  232,  236,  238,  248,  253,  254,  256,  258,
  265,  267,  268,  269,  273,  274,  276,    0,  277,    0,
  282,  284,  288,  292,  293,  295,  297,  299,  300,  301,
  303,  306,  307,  317,  321,  322,  329, -122,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 -242, -228, -232,    0,  331,  333,  334,  338,  339,  342,
  343,  344, -107,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  345,  346, -114,    0,    0,    0,    0,
  110,    0, -236,    0,  349,  350,  351,  352,  353,  358,
  137,    0,    0,    0,    0,    0,    0,    0,    0,  359,
  360,  361,  364,  372,  373,  377,  381,  385,  389,  -76,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, -235, -233, -152,  -84,   58,  392,    0,    0,  394,
  396,  397,    0,  398,  400,  401,  407,  408,  409,  411,
  412,  413,  416,  417,   42,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   80,  103,   51,  107,  107,  108,  111,   56,   59,
   60,   61,   64,   65,   66,  421,    0,  172,  585,    0,
  427,  432, -118,    0,    0,    0,    0,  436, -103,    0,
    0,    0,  437,  443, -112,    0,    0,    0,   76,  107,
   77,  107,  139,  114,  141,   79,   93,   94,  152,  116,
  101,  156,  160,  163,  112,  107,  118,  173,  147,  121,
  178,  179,  180,  107,  182,  166,  183,  190,  127,  485,
  140,  500,  107,  107,  142,  168,  145,  148, -367, -304,
  149,  150,  107,  107,  193,  107,  157,  161,  164,  506,
    0,    0,    0,  512,  515,    0,  529,  534,  -92,    0,
    0,    0,    0,    0,    0,    0,    0,  536,  539, -119,
    0,    0,    0,    0,  540,  541,  542, -110,    0,    0,
    0,    0,  213,  222,  225,  226,  -79,  229,  230,  174,
  555,    0,  231,  234,  562,    0,  337,    0,  565,  569,
  574, -121,    0,    0,    0,    0,  211,  212,  214,  215,
  223,  107,  580,    0,  262,  228,  272,  275,  278,  279,
  285,  283,  286,  287,  593,    0,    0,  601,    0,  602,
 -120,    0,    0,    0,    0,    0,  607,    0, -113,    0,
    0,    0,  611,  627,  629,    0,  260,  298,  261,  632,
  266,  270,  271,  280,  294,  311,  319,  312,  315,  305,
  318,  638,    0,  657,  663,  664, -337,  666,  668,  669,
  670,  672,  680,  681,  683,  684,  686,  687,    0,    0,
  689,  690,  692,  693,  694,  698,  700,  701,  702,   31,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  703,  705,  706,  707,  708,  709,  710,  711,  715,
    0,  716,  717,  719,  720,  721,  724,  725,  170,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  393,  399,  688,
    0,  404,  730,    0,  405,  406,  731,    0,  732,  733,
  742,  745,  747,  750,  752,  755,  756,  759,  760,  762,
  764,  766,  769,  770,  771,  779,  780,  781,  784,  787,
  788,  792,  793,  796,  802,  807,  808,  810,  811,  547,
  814,  579,  816,  817,  818,  823,  826,  828,  829,  830,
  835,  837,  838,  839,  840,  841, -222,  842,  843,  844,
  845,  846,    0,  847,  107,  479,  851,  519,  521,  858,
    0,  524,  525,  861,    0,  527,  528,  549,  868,    0,
  869,  874,  875,  876,  877,  878,  879,  880,  881,  882,
  883,  884,  885,  886,    0,  887,  889,    0,    0,  888,
  891,  893,  894,    0,  895,  896,  897,  898,  901,  903,
  906,  907,  908,  909,  910,  911,  912,  -34,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  582,  583,  586,
  915,    0,  920,  922,  928,  934,  935,  937,    0,  938,
  940,  941,  942,  943,  944,  945,  953,  954,  960,    0,
  631,  965,  634,  962,    0,  635,  969,  972,    0,    0,
    0,    0,  973,  974,  976,  557,  977,  985,  986,  988,
  989,  990,  991,  992,  993,  994,  995,    0,    0,    0,
    0,  107,  107,  107,  107,  107,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  107,
  679,  682,  685,  691,  662,  695,  107,  193,  998,    0,
  665, -318,  630,  671,  674,  633,  636,  639,  676, 1001,
  678,  696,  697,  699,  704,  712,  713, 1005,    0, 1014,
 1015,    0, 1016,    0, 1017, 1018,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  -18,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   -6,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  193,
  193,  193,    0,    0,    0,    0,    0,    0,    0, -257,
 1019, 1020, -247, 1022, 1023,    0, 1024, 1025,    0, 1026,
 1027,  652,    8,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  658,  714,  659,  667, 1031,  673,  675,  718,  722,
  723,  726,  727,  728,  729,  734,  735,  736,  737, 1035,
    0, 1036, 1037, 1039,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, 1040,  347, 1041,    0, 1042,  181,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  609,
    0,    0,   18,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, 1043, 1045, 1050, 1051, 1052, 1053, 1054, 1055, 1056,
    0, 1057, 1059, 1060, 1061, 1063, 1064, 1065, 1066, 1067,
 1068, -223, 1070, 1072, 1073, 1074, 1075, 1076, 1077,    0,
    0,    0,    0,    0,    0,    0,  547,    0,  579,    0,
    0,    0,    0,    0,   40,    0,    0,    0,    0,    0,
   41,    0,    0,    0,    0,    0,    0,    0,  761,    0,
  549, 1079, 1080, 1081, 1082,  374, 1083, 1084, 1085, 1086,
 1087, 1088, 1090, 1091, 1092, 1094, 1095, 1096, 1098,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   45,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   50,    0,    0,    0,  557,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   57,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0, -257,    0, -247,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  395,    0,    0,    0,    0,    0,    0,    0,   62,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  347,    0,  181,    0,
    0, -223,    0,    0,    0,    0,  374,    0,    0,    0,
    0,
};
const short yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0, 1038, 1046,
    0,    0,    0,    0,    0,    0,    0,    0,    0, 1047,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0, 1101,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0, 1103,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, 1101, 1101, 1101, 1101, 1101,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, 1103,
 1103, 1103,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   63,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,
};
const short yygindex[] = {                                      0,
 -335, -481, -413, -830,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  917,    0,    0,    0,
  892,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, 1104,    0,    0,    0,    0,  931,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  438,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  -86,  -54,    0,    0,    0,    0,  613,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  738,
    0,    0,    0,    0,   55,    0,    0,  860,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    9,  144,    0,    0,  739,
    0,    0,    0,    0,    0,  677,    0,    0,    0,    0,
    0,  -68,    0,    0,  740,    0,    0,    0,    0,  -67,
    0,    0,    0,    0,  591,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  -71,    0,    0,  743,    0,    0,
    0,    0,  832,    0,    0,    0,    0,  831,    0,    0,
    0,  822,    0,    0,    0, 1021,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   89,
    0,    0,   95,    0,    0,  765,    0,    0,    0,    0,
    0,    0,    0,    0,  -16,    0,    0,  -12,    0, 1105,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  936,    0,    0,    0,    0,
    0,    0,
};
#define YYTABLESIZE 1249
const short yytable[] = {                                     538,
  539,  668,  420,  751,  774,  684,  610,  357, 1103,  350,
  465,  778,  617,  422,  689,  423,  297,  461, 1109,  468,
  497,  613,  506,  444,  254, 1097,   46,  437,   48,  362,
  107,   44,  680,   54,  620,   58,  622, 1099,  537,  469,
 1096, 1188,   59, 1189,  243,  940,  941,  942,  495,   66,
  636, 1121, 1098,   62,  424, 1190,   63,  425,  644, 1191,
  255, 1168,  659,  660,  224,   75, 1120,  653,  654,  802,
  803,  804,  805,  806,  110,  256, 1167,  665,  666,  113,
  669,  114,   67, 1205, 1207,  358,  115,  351, 1247,  221,
 1000,  257,   68, 1249,  258,  259,  445,   45, 1204, 1206,
 1252,  446,  222, 1246,  426, 1257,  208,  223, 1248, 1100,
 1101, 1102,  250,  260,  253, 1251,  225,  226,  227, 1192,
 1256,  208,  427,  292,  228,  661,  662, 1073, 1074,  498,
  294,  507,  470,  116,  468,  497,  437,  350,  363,  117,
  118,  243,  506,  362,  119,  444,  758,   66,  224,  352,
  120,  244,  357,  667,  469,  829,  229,  121,   69,  471,
  447,  122,  123,  422,  295,  423,  532,  438,  124,  364,
  346,  125,  126,  127, 1104,  128,  293,  296,  245,  269,
   67,  129,  332,  333, 1110,  499,  334,  508,  335,  230,
   68,  336,  337,  338,  339,  130,  131,  348,  340,  132,
  225,  226,  227,  341,  424,  133,  342,  425,  228,  134,
  135,  343,  270,  136,  344,  351,  137,  138,  445,  345,
  349,  709,  369,  446,  710,  370,  139,  140,  428,  371,
  358,  372,  467,  141,  142,  500,  143,  144,  145,  146,
  229,  513,  439,  711,  498,  373,  374,  470,  244,  375,
  147,  507,  363,  271,  426,  712,   69,  231,  376,  148,
  149,  483,  150,  377,  151,  152,  713,  378,  153,  379,
  380,  714,  427,  230,  471,  245,  438,  352,  715,  381,
  382,  383,  447,  364,  232,  716,  550,  384,  272,  717,
  273,  274,  385,  154,  848,  155,  386,  299,  387,  156,
  499,   76,  718,  157,  158,  159,  160,  508,  388,  514,
  161,  162,  551,  389,  390,  300,  391,  163,  392,  301,
 1057, 1058, 1059, 1060, 1061,  393,  275,  394,  395,  396,
  719,   77,   78,  397,  398,  720,  399,  401,   79,  951,
  276,  231,  403,  302,  404,  164,  165,  303,  405,  166,
  500,  439,  406,  407,  721,  408,  304,  409,  167,  410,
  411,  412,  305,  413,  722,  723,  414,  415,  232,  724,
  695,  696,  697,  698,  699,  700,  701,  416,  428,  306,
  277,  417,  418,  552,  553,  554,   80,   81,  555,  419,
  269,  453,  254,  454,  455,  556,   82,   83,  456,  457,
  278,  279,  458,  459,  460,  463,  464,  307,  557,  477,
  478,  479,  480,  481, 1070,  308,   84,   85,  482,  485,
  486,  487,  558,  270,  488,  571,  572,  550,  255,  573,
  309,   86,  489,  490,  574,  725,  726,  491,  310,  311,
   87,  492,  559,  256,  727,  493,  575,  576,  577,  494,
  516,  515,  578,  551,  517,  534,  518,  519,  521,  257,
  522,  523,  258,  259,  271,  312,  313,  524,  525,  526,
  579,  527,  528,  529,  580,  581,  530,  531,  535,  549,
  536,  260,  537,  540, 1062,  542,  541,  608,  543,  544,
  545, 1069,  609,  546,  547,  548,  612,  615,  582,  272,
  583,  273,  274,  616,  116,  619,  621,  624,  626,  630,
  117,  118,  314,  584,  623,  119,  625, 1156,   88,   89,
   90,  120,  627,  628,  552,  553,  554,  629,  121,  555,
  631,  632,  122,  123,  585,  633,  556,  275,  634,  124,
  639,  635,  125,  126,  127,  650,  128,  637,  638,  557,
  640,  276,  129,  641,  642,  643,  649,  645,  647,  646,
  652,  656,  586,  558,  673,  648,  130,  131,  667,  651,
  132,  655,  675,  587,  657,  676,  133,  658,  663,  664,
  134,  135,  588,  559,  136, 1157,  670,  137,  138,  678,
  671,  277,  709,  672,  679,  710,  682,  139,  140,  683,
  686,  687,  688,  704,  141,  142,  691,  143,  144,  145,
  146,  278,  279,  705,  711,  692, 1158,   76,  693,  694,
  708,  147,  702,  703,  706,  748,  712,  707, 1159,  749,
  148,  149, 1214,  150,  750,  151,  152,  713,  759,  153,
  753,  754,  714,  755,  756, 1160, 1161,   77,   78,  715,
 1162,  770,  757, 1214,   79,  760,  716,  761,  767, 1163,
  717,  771,  773, 1215,  154,  762,  155,  776,  763,  780,
  156,  764,  765,  718,  157,  158,  159,  160,  766,  768,
  769,  161,  162, 1145, 1215,  781, 1216,  782,  163,  783,
  785,  784,  786, 1217,  793,  787,  798, 1218, 1219,  788,
  789,  719,   80,   81,  792,  794,  720, 1216,  795,  790,
 1220,  797,   82,   83, 1217,  799,  164,  165, 1218, 1219,
  166,  800,  801,  791,  809,  721,  810,  811,  812,  167,
  813, 1220,   84,   85,  796,  722,  723,  299,  814,  815,
  724,  816,  817, 1221,  818,  819,  852,   86, 1222,  820,
  821, 1146,  822,  823,  824,  300,   87, 1223,  825,  301,
  826,  827,  828,  831, 1221,  832,  833,  834,  835,  836,
  837,  838, 1224, 1225, 1226,  839,  841,  842, 1223,  843,
  844,  845, 1147,  302,  846,  847,  850,  303,  854,  857,
  858,  859,  851, 1224, 1225, 1226,  304,  853,  855,  856,
  860,    2,  305,  861,    3,  862,  725,  726,  863,    4,
  864, 1148, 1149,  865,  866,  727, 1150,  867,  868,  306,
  869,    5,  870,    6,  871, 1151,    7,  872,  873,  874,
 1032, 1033, 1227,    8,   88,   89,   90,  875,  876,  877,
  571,  572,  878, 1228,  573,  879,  880,  307,    9,  574,
  881,  882, 1229, 1227,  883,  308,   10,   11, 1034,   12,
  884,  575,  576,  577, 1228,  885,  886,  578,  887,  888,
  309, 1035,  907, 1229,  926,  927,  928, 1036,  310,  311,
   13,  929, 1032, 1033,  930,  579,  931,  932,  933,  580,
  581,   14,   15,  934, 1037,  935,  936,  937,  938,  939,
  945,  946,  947,  948,  949,  312,  313,  950,  952,   16,
 1034,  953,  954,  582,  955,  583,  956,  957,  958,  959,
  960,  961, 1038, 1035,  962,   17,  965,  966,  584, 1036,
 1039, 1040,  967,  968,  969,  970,  971,  972,  973,  974,
  975,  976,  977,  978,  979,  980, 1037,  981,  982,  585,
   18,  983,  314,  984,  985,  987,  988,  989,  990,   19,
   20,  991, 1041,  992,   21,   22,  993,  994,  995,  996,
  997,  998,  999, 1005, 1038, 1002, 1003,  586, 1006, 1004,
 1007, 1042, 1039,  889,  890,  891, 1008,  892,  587,  893,
  894,  895, 1009, 1010,  896, 1011, 1012,  588, 1013, 1014,
 1015, 1016, 1017, 1018,  897,  898,  899,  900,  901,  902,
  903, 1019, 1020,  904, 1041,  908,  909,  910, 1021,  911,
 1025,  912,  913,  914, 1022, 1023,  915, 1024, 1026, 1027,
 1028, 1029, 1030, 1042, 1031, 1046,  916,  917,  918,  919,
  920,  921,  922, 1047, 1048,  923, 1049, 1050, 1051, 1052,
 1053, 1054, 1055, 1056, 1063, 1067, 1071, 1064, 1072, 1075,
 1065, 1082, 1078, 1090, 1076, 1079, 1066, 1077, 1080, 1081,
 1068, 1083, 1091, 1092, 1093, 1094, 1095, 1107, 1108, 1087,
 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1122, 1124, 1084,
 1085, 1126, 1086, 1140, 1141, 1142, 1125, 1143, 1144, 1154,
 1155, 1169, 1127, 1170, 1128, 1088, 1089, 1123, 1171, 1172,
 1173, 1174, 1175, 1176, 1177, 1178, 1131, 1179, 1180, 1181,
 1133, 1182, 1183, 1184, 1185, 1186, 1187, 1136, 1195, 1138,
 1196, 1197, 1198, 1199, 1200, 1201, 1208, 1210, 1211, 1212,
 1213, 1233, 1234, 1235, 1236, 1237, 1238, 1129, 1239, 1240,
 1241, 1130, 1242, 1243, 1244, 1132, 1245, 1134, 1135,   25,
  173,   33,  466,  462, 1137, 1001, 1139, 1255,  316,  109,
 1261,  496,  830,  298,  533, 1209, 1250,  775, 1258,  849,
 1260, 1259,  685, 1166,  611,  690,  618, 1203,  421,  614,
 1254, 1202, 1253,  681,    0,  347,  484,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  752,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  779,
};
const short yycheck[] = {                                     335,
  336,  415,  125,  125,  125,  125,  125,  256,  266,  256,
  125,  125,  125,  256,  125,  258,  125,  125,  266,  256,
  256,  125,  256,  256,  256,   44,  123,  256,  123,  256,
  394,   59,  125,  123,  370,  123,  372,   44,  376,  276,
   59,  265,  123,  267,  256,  268,  269,  270,  125,  256,
  386,   44,   59,  123,  297,  279,  123,  300,  394,  283,
  292,   44,  430,  431,  256,  123,   59,  403,  404,  407,
  408,  409,  410,  411,  394,  307,   59,  413,  414,  123,
  416,  123,  289,   44,   44,  334,  123,  334,   44,  123,
  125,  323,  299,   44,  326,  327,  329,  125,   59,   59,
   44,  334,  123,   59,  347,   44,   44,  123,   59,  940,
  941,  942,  394,  345,  123,   59,  308,  309,  310,  343,
   59,   59,  365,  123,  316,  430,  431,  446,  447,  365,
   61,  365,  369,  256,  256,  256,  256,  256,  365,  262,
  263,  256,  256,  256,  267,  256,  482,  256,  256,  396,
  273,  363,  256,  376,  276,  125,  348,  280,  365,  396,
  393,  284,  285,  256,   61,  258,  125,  396,  291,  396,
  125,  294,  295,  296,  432,  298,  123,   61,  390,  256,
  289,  304,   61,   61,  432,  421,   61,  421,   61,  381,
  299,   61,   61,   61,   61,  318,  319,  123,   61,  322,
  308,  309,  310,   61,  297,  328,   61,  300,  316,  332,
  333,   61,  289,  336,   61,  334,  339,  340,  329,   61,
  123,  256,   61,  334,  259,   61,  349,  350,  471,   61,
  334,   61,  123,  356,  357,  471,  359,  360,  361,  362,
  348,  394,  471,  278,  365,   61,   61,  369,  363,   61,
  373,  365,  365,  330,  347,  290,  365,  449,   61,  382,
  383,  125,  385,   61,  387,  388,  301,   61,  391,   61,
   61,  306,  365,  381,  396,  390,  396,  396,  313,   61,
   61,   61,  393,  396,  476,  320,  256,   61,  365,  324,
  367,  368,   61,  416,  125,  418,   61,  256,   61,  422,
  421,  256,  337,  426,  427,  428,  429,  421,   61,  394,
  433,  434,  282,   61,   61,  274,   61,  440,   61,  278,
  802,  803,  804,  805,  806,   61,  403,   61,   61,   61,
  365,  286,  287,   61,   61,  370,   61,   61,  293,  675,
  417,  449,   61,  302,   61,  468,  469,  306,   61,  472,
  471,  471,   61,   61,  389,   61,  315,   61,  481,   61,
   61,   61,  321,   61,  399,  400,   61,   61,  476,  404,
  450,  451,  452,  453,  454,  455,  456,   61,  471,  338,
  457,   61,   61,  353,  354,  355,  341,  342,  358,   61,
  256,   61,  256,   61,   61,  365,  351,  352,   61,   61,
  477,  478,   61,   61,   61,   61,   61,  366,  378,   61,
   61,   61,   61,   61,  828,  374,  371,  372,   61,   61,
   61,   61,  392,  289,   61,  256,  257,  256,  292,  260,
  389,  386,   61,   61,  265,  470,  471,   61,  397,  398,
  395,   61,  412,  307,  479,   61,  277,  278,  279,   61,
   59,  394,  283,  282,   61,  376,   61,   61,   61,  323,
   61,   61,  326,  327,  330,  424,  425,   61,   61,   61,
  301,   61,   61,   61,  305,  306,   61,   61,  376,   59,
  430,  345,  376,  376,  820,  430,  376,   61,  430,  430,
  430,  827,   61,  430,  430,  430,   61,   61,  329,  365,
  331,  367,  368,   61,  256,  430,  430,  394,  430,  394,
  262,  263,  471,  344,  376,  267,  376,  337,  473,  474,
  475,  273,  430,  430,  353,  354,  355,  376,  280,  358,
  430,  376,  284,  285,  365,  376,  365,  403,  376,  291,
  394,  430,  294,  295,  296,   61,  298,  430,  376,  378,
  430,  417,  304,  376,  376,  376,  430,  376,  376,  394,
   61,  394,  393,  392,   59,  376,  318,  319,  376,  430,
  322,  430,   61,  404,  430,   61,  328,  430,  430,  430,
  332,  333,  413,  412,  336,  405,  430,  339,  340,   61,
  430,  457,  256,  430,   61,  259,   61,  349,  350,   61,
   61,   61,   61,  430,  356,  357,  394,  359,  360,  361,
  362,  477,  478,   59,  278,  394,  436,  256,  394,  394,
   59,  373,  394,  394,  394,   61,  290,  394,  448,   61,
  382,  383,  259,  385,   61,  387,  388,  301,   59,  391,
  430,  430,  306,  430,  430,  465,  466,  286,  287,  313,
  470,   59,  430,  259,  293,  394,  320,  430,  376,  479,
  324,   61,   61,  290,  416,  394,  418,   61,  394,   59,
  422,  394,  394,  337,  426,  427,  428,  429,  394,  394,
  394,  433,  434,  337,  290,   59,  313,   59,  440,  430,
  430,  394,   61,  320,  376,  430,   59,  324,  325,  430,
  430,  365,  341,  342,  394,  394,  370,  313,  394,  430,
  337,  394,  351,  352,  320,   59,  468,  469,  324,  325,
  472,   59,   59,  430,   59,  389,   59,   59,   59,  481,
   59,  337,  371,  372,  430,  399,  400,  256,   59,   59,
  404,   59,   59,  370,   59,   59,   59,  386,  375,   61,
   61,  405,   61,   61,   61,  274,  395,  384,   61,  278,
   61,   61,   61,   61,  370,   61,   61,   61,   61,   61,
   61,   61,  399,  400,  401,   61,   61,   61,  384,   61,
   61,   61,  436,  302,   61,   61,  394,  306,   59,   59,
   59,   59,  394,  399,  400,  401,  315,  394,  394,  394,
   59,  256,  321,   59,  259,   59,  470,  471,   59,  264,
   59,  465,  466,   59,   59,  479,  470,   59,   59,  338,
   59,  276,   59,  278,   59,  479,  281,   59,   59,   59,
  274,  275,  459,  288,  473,  474,  475,   59,   59,   59,
  256,  257,   59,  470,  260,   59,   59,  366,  303,  265,
   59,   59,  479,  459,   59,  374,  311,  312,  302,  314,
   59,  277,  278,  279,  470,   59,   59,  283,   59,   59,
  389,  315,   59,  479,   59,   59,   59,  321,  397,  398,
  335,   59,  274,  275,   59,  301,   59,   59,   59,  305,
  306,  346,  347,   59,  338,   59,   59,   59,   59,   59,
   59,   59,   59,   59,   59,  424,  425,   61,  430,  364,
  302,   61,  394,  329,  394,  331,   59,  394,  394,   59,
  394,  394,  366,  315,  376,  380,   59,   59,  344,  321,
  374,  375,   59,   59,   59,   59,   59,   59,   59,   59,
   59,   59,   59,   59,   59,   59,  338,   59,   61,  365,
  405,   61,  471,   61,   61,   61,   61,   61,   61,  414,
  415,   61,  406,   61,  419,  420,   61,   61,   61,   61,
   61,   61,   61,   59,  366,  394,  394,  393,   59,  394,
   59,  425,  374,  437,  438,  439,   59,  441,  404,  443,
  444,  445,   59,   59,  448,   59,   59,  413,   59,   59,
   59,   59,   59,   59,  458,  459,  460,  461,  462,  463,
  464,   59,   59,  467,  406,  437,  438,  439,   59,  441,
   59,  443,  444,  445,  394,   61,  448,  394,  394,   61,
   59,   59,   59,  425,   59,   59,  458,  459,  460,  461,
  462,  463,  464,   59,   59,  467,   59,   59,   59,   59,
   59,   59,   59,   59,  376,  394,   59,  376,  394,  430,
  376,   61,  430,   59,  394,  430,  376,  394,  430,  394,
  376,  394,   59,   59,   59,   59,   59,   59,   59,  376,
   59,   59,   59,   59,   59,   59,  435,  430,  430,  394,
  394,   61,  394,   59,   59,   59,  430,   59,   59,   59,
   59,   59,  430,   59,  430,  394,  394,  394,   59,   59,
   59,   59,   59,   59,   59,   59,  394,   59,   59,   59,
  394,   59,   59,   59,   59,   59,   59,  394,   59,  394,
   59,   59,   59,   59,   59,   59,  376,   59,   59,   59,
   59,   59,   59,   59,   59,   59,   59,  430,   59,   59,
   59,  430,   59,   59,   59,  430,   59,  430,  430,   59,
  123,   59,  246,  233,  430,  728,  430, 1222,  123,  123,
 1257,  280,  560,   70,  315, 1121, 1168,  501, 1247,  589,
 1252, 1249,  440, 1040,  353,  448,  365, 1099,  168,  359,
 1207, 1097, 1205,  429,   -1,   91,  261,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  472,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  509,
};
#define YYFINAL 1
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 481
#if YYDEBUG
const char * const yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,"','",0,0,0,0,0,0,0,0,0,0,0,0,0,0,"';'",0,"'='",0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
"ACCEPT_PASSWORD","ACTION","ADMIN","AFTYPE","T_ALLOW","ANTI_NICK_FLOOD",
"ANTI_SPAM_EXIT_MESSAGE_TIME","IRCD_AUTH","AUTOCONN","T_BLOCK","BURST_AWAY",
"BYTES","KBYTES","MBYTES","GBYTES","TBYTES","CALLER_ID_WAIT","CAN_FLOOD",
"CAN_IDLE","CHANNEL","CIPHER_PREFERENCE","CLASS","COMPRESSED",
"COMPRESSION_LEVEL","CONNECT","CONNECTFREQ","CRYPTLINK",
"DEFAULT_CIPHER_PREFERENCE","DEFAULT_FLOODCOUNT","DEFAULT_SPLIT_SERVER_COUNT",
"DEFAULT_SPLIT_USER_COUNT","DENY","DESCRIPTION","DIE","DISABLE_AUTH",
"DISABLE_HIDDEN","DISABLE_LOCAL_CHANNELS","DISABLE_REMOTE_COMMANDS",
"DOT_IN_IP6_ADDR","DOTS_IN_IDENT","DURATION","EGDPOOL_PATH","EMAIL","ENABLE",
"ENCRYPTED","EXCEED_LIMIT","EXEMPT","FAILED_OPER_NOTICE","FAKENAME",
"IRCD_FLAGS","FLATTEN_LINKS","FFAILED_OPERLOG","FOPERLOG","FUSERLOG","GECOS",
"GENERAL","GLINE","GLINES","GLINE_EXEMPT","GLINE_LOG","GLINE_TIME",
"GLINE_MIN_CIDR","GLINE_MIN_CIDR6","GLOBAL_KILL","NEED_IDENT",
"HAVENT_READ_CONF","HIDDEN","HIDDEN_ADMIN","HIDDEN_OPER","HIDE_SERVER_IPS",
"HIDE_SERVERS","HIDE_SPOOF_IPS","HOST","HUB","HUB_MASK","IDLETIME",
"IGNORE_BOGUS_TS","IP","KILL","KILL_CHASE_TIME_LIMIT","KLINE","KLINE_EXEMPT",
"KLINE_REASON","KLINE_WITH_REASON","KNOCK_DELAY","KNOCK_DELAY_CHANNEL",
"LAZYLINK","LEAF_MASK","LINKS_DELAY","LISTEN","LOGGING","LOG_LEVEL",
"MAXIMUM_LINKS","MAX_ACCEPT","MAX_BANS","MAX_CHANS_PER_USER","MAX_GLOBAL",
"MAX_IDENT","MAX_LOCAL","MAX_NICK_CHANGES","MAX_NICK_TIME","MAX_NUMBER",
"MAX_TARGETS","MESSAGE_LOCALE","MIN_NONWILDCARD","MIN_NONWILDCARD_SIMPLE",
"MODULE","MODULES","NAME","NEED_PASSWORD","NETWORK_DESC","NETWORK_NAME","NICK",
"NICK_CHANGES","NO_CREATE_ON_SPLIT","NO_JOIN_ON_SPLIT","NO_OPER_FLOOD",
"NO_TILDE","NOT","NUMBER","NUMBER_PER_IDENT","NUMBER_PER_IP",
"NUMBER_PER_IP_GLOBAL","OPERATOR","OPER_LOG","OPER_ONLY_UMODES",
"OPER_PASS_RESV","OPER_SPY_T","OPER_UMODES","INVITE_OPS_ONLY","PACE_WAIT",
"PACE_WAIT_SIMPLE","PASSWORD","PATH","PING_COOKIE","PING_TIME","PORT","QSTRING",
"QUIET_ON_BAN","REASON","REDIRPORT","REDIRSERV","REHASH","REMOTE","REMOTEBAN",
"RESTRICTED","RSA_PRIVATE_KEY_FILE","RSA_PUBLIC_KEY_FILE","RESV","RESV_EXEMPT",
"SECONDS","MINUTES","HOURS","DAYS","WEEKS","SENDQ","SEND_PASSWORD","SERVERHIDE",
"SERVERINFO","SERVLINK_PATH","SID","TKLINE_EXPIRE_NOTICES","T_SHARED",
"T_CLUSTER","TYPE","SHORT_MOTD","SILENT","SPOOF","SPOOF_NOTICE",
"STATS_I_OPER_ONLY","STATS_K_OPER_ONLY","STATS_O_OPER_ONLY","STATS_P_OPER_ONLY",
"TBOOL","TMASKED","T_REJECT","TS_MAX_DELTA","TS_WARN_DELTA","TWODOTS","T_ALL",
"T_BOTS","T_CALLERID","T_CCONN","T_CLIENT_FLOOD","T_DEBUG","T_DRONE",
"T_EXTERNAL","T_FULL","T_INVISIBLE","T_IPV4","T_IPV6","T_LOCOPS","T_LOGPATH",
"T_L_CRIT","T_L_DEBUG","T_L_ERROR","T_L_INFO","T_L_NOTICE","T_L_TRACE",
"T_L_WARN","T_MAX_CLIENTS","T_NCHANGE","T_OPERWALL","T_REJ","T_SERVNOTICE",
"T_SKILL","T_SPY","T_UNAUTH","T_UNRESV","T_UNXLINE","T_WALLOP","THROTTLE_TIME",
"TRUE_NO_OPER_FLOOD","UNKLINE","USER","USE_EGD","USE_EXCEPT","USE_INVEX",
"USE_KNOCK","USE_LOGGING","VHOST","VHOST6","XLINE","WARN","WARN_NO_NLINE",
};
const char * const yyrule[] = {
"$accept : conf",
"conf :",
"conf : conf conf_item",
"conf_item : admin_entry",
"conf_item : logging_entry",
"conf_item : oper_entry",
"conf_item : channel_entry",
"conf_item : class_entry",
"conf_item : listen_entry",
"conf_item : auth_entry",
"conf_item : serverinfo_entry",
"conf_item : serverhide_entry",
"conf_item : resv_entry",
"conf_item : shared_entry",
"conf_item : cluster_entry",
"conf_item : connect_entry",
"conf_item : kill_entry",
"conf_item : deny_entry",
"conf_item : exempt_entry",
"conf_item : general_entry",
"conf_item : gline_entry",
"conf_item : gecos_entry",
"conf_item : modules_entry",
"conf_item : error ';'",
"conf_item : error '}'",
"timespec_ :",
"timespec_ : timespec",
"timespec : NUMBER timespec_",
"timespec : NUMBER SECONDS timespec_",
"timespec : NUMBER MINUTES timespec_",
"timespec : NUMBER HOURS timespec_",
"timespec : NUMBER DAYS timespec_",
"timespec : NUMBER WEEKS timespec_",
"sizespec_ :",
"sizespec_ : sizespec",
"sizespec : NUMBER sizespec_",
"sizespec : NUMBER BYTES sizespec_",
"sizespec : NUMBER KBYTES sizespec_",
"sizespec : NUMBER MBYTES sizespec_",
"modules_entry : MODULES '{' modules_items '}' ';'",
"modules_items : modules_items modules_item",
"modules_items : modules_item",
"modules_item : modules_module",
"modules_item : modules_path",
"modules_item : error",
"modules_module : MODULE '=' QSTRING ';'",
"modules_path : PATH '=' QSTRING ';'",
"serverinfo_entry : SERVERINFO '{' serverinfo_items '}' ';'",
"serverinfo_items : serverinfo_items serverinfo_item",
"serverinfo_items : serverinfo_item",
"serverinfo_item : serverinfo_name",
"serverinfo_item : serverinfo_vhost",
"serverinfo_item : serverinfo_hub",
"serverinfo_item : serverinfo_description",
"serverinfo_item : serverinfo_network_name",
"serverinfo_item : serverinfo_network_desc",
"serverinfo_item : serverinfo_max_clients",
"serverinfo_item : serverinfo_rsa_private_key_file",
"serverinfo_item : serverinfo_vhost6",
"serverinfo_item : serverinfo_sid",
"serverinfo_item : error",
"serverinfo_rsa_private_key_file : RSA_PRIVATE_KEY_FILE '=' QSTRING ';'",
"serverinfo_name : NAME '=' QSTRING ';'",
"serverinfo_sid : SID '=' QSTRING ';'",
"serverinfo_description : DESCRIPTION '=' QSTRING ';'",
"serverinfo_network_name : NETWORK_NAME '=' QSTRING ';'",
"serverinfo_network_desc : NETWORK_DESC '=' QSTRING ';'",
"serverinfo_vhost : VHOST '=' QSTRING ';'",
"serverinfo_vhost6 : VHOST6 '=' QSTRING ';'",
"serverinfo_max_clients : T_MAX_CLIENTS '=' NUMBER ';'",
"serverinfo_hub : HUB '=' TBOOL ';'",
"admin_entry : ADMIN '{' admin_items '}' ';'",
"admin_items : admin_items admin_item",
"admin_items : admin_item",
"admin_item : admin_name",
"admin_item : admin_description",
"admin_item : admin_email",
"admin_item : error",
"admin_name : NAME '=' QSTRING ';'",
"admin_email : EMAIL '=' QSTRING ';'",
"admin_description : DESCRIPTION '=' QSTRING ';'",
"logging_entry : LOGGING '{' logging_items '}' ';'",
"logging_items : logging_items logging_item",
"logging_items : logging_item",
"logging_item : logging_path",
"logging_item : logging_oper_log",
"logging_item : logging_gline_log",
"logging_item : logging_log_level",
"logging_item : logging_use_logging",
"logging_item : logging_fuserlog",
"logging_item : logging_foperlog",
"logging_item : logging_ffailed_operlog",
"logging_item : error",
"logging_path : T_LOGPATH '=' QSTRING ';'",
"logging_oper_log : OPER_LOG '=' QSTRING ';'",
"logging_gline_log : GLINE_LOG '=' QSTRING ';'",
"logging_fuserlog : FUSERLOG '=' QSTRING ';'",
"logging_ffailed_operlog : FFAILED_OPERLOG '=' QSTRING ';'",
"logging_foperlog : FOPERLOG '=' QSTRING ';'",
"logging_log_level : LOG_LEVEL '=' T_L_CRIT ';'",
"logging_log_level : LOG_LEVEL '=' T_L_ERROR ';'",
"logging_log_level : LOG_LEVEL '=' T_L_WARN ';'",
"logging_log_level : LOG_LEVEL '=' T_L_NOTICE ';'",
"logging_log_level : LOG_LEVEL '=' T_L_TRACE ';'",
"logging_log_level : LOG_LEVEL '=' T_L_INFO ';'",
"logging_log_level : LOG_LEVEL '=' T_L_DEBUG ';'",
"logging_use_logging : USE_LOGGING '=' TBOOL ';'",
"$$1 :",
"oper_entry : OPERATOR $$1 oper_name_b '{' oper_items '}' ';'",
"oper_name_b :",
"oper_name_b : oper_name_t",
"oper_items : oper_items oper_item",
"oper_items : oper_item",
"oper_item : oper_name",
"oper_item : oper_user",
"oper_item : oper_password",
"oper_item : oper_hidden_admin",
"oper_item : oper_class",
"oper_item : oper_global_kill",
"oper_item : oper_remote",
"oper_item : oper_kline",
"oper_item : oper_xline",
"oper_item : oper_unkline",
"oper_item : oper_gline",
"oper_item : oper_nick_changes",
"oper_item : oper_die",
"oper_item : oper_rehash",
"oper_item : oper_admin",
"oper_item : oper_encrypted",
"oper_item : oper_rsa_public_key_file",
"oper_item : oper_flags",
"oper_item : error",
"oper_name : NAME '=' QSTRING ';'",
"oper_name_t : QSTRING",
"oper_user : USER '=' QSTRING ';'",
"oper_password : PASSWORD '=' QSTRING ';'",
"oper_encrypted : ENCRYPTED '=' TBOOL ';'",
"oper_hidden_admin : HIDDEN_ADMIN '=' TBOOL ';'",
"oper_rsa_public_key_file : RSA_PUBLIC_KEY_FILE '=' QSTRING ';'",
"oper_class : CLASS '=' QSTRING ';'",
"oper_global_kill : GLOBAL_KILL '=' TBOOL ';'",
"oper_remote : REMOTE '=' TBOOL ';'",
"oper_kline : KLINE '=' TBOOL ';'",
"oper_xline : XLINE '=' TBOOL ';'",
"oper_unkline : UNKLINE '=' TBOOL ';'",
"oper_gline : GLINE '=' TBOOL ';'",
"oper_nick_changes : NICK_CHANGES '=' TBOOL ';'",
"oper_die : DIE '=' TBOOL ';'",
"oper_rehash : REHASH '=' TBOOL ';'",
"oper_admin : ADMIN '=' TBOOL ';'",
"$$2 :",
"oper_flags : IRCD_FLAGS $$2 '=' oper_flags_items ';'",
"oper_flags_items : oper_flags_items ',' oper_flags_item",
"oper_flags_items : oper_flags_item",
"oper_flags_item : NOT oper_flags_item_atom",
"oper_flags_item : oper_flags_item_atom",
"oper_flags_item_atom : GLOBAL_KILL",
"oper_flags_item_atom : REMOTE",
"oper_flags_item_atom : KLINE",
"oper_flags_item_atom : UNKLINE",
"oper_flags_item_atom : XLINE",
"oper_flags_item_atom : GLINE",
"oper_flags_item_atom : DIE",
"oper_flags_item_atom : REHASH",
"oper_flags_item_atom : ADMIN",
"oper_flags_item_atom : HIDDEN_ADMIN",
"oper_flags_item_atom : NICK_CHANGES",
"oper_flags_item_atom : T_OPERWALL",
"oper_flags_item_atom : OPER_SPY_T",
"oper_flags_item_atom : HIDDEN_OPER",
"oper_flags_item_atom : REMOTEBAN",
"$$3 :",
"class_entry : CLASS $$3 class_name_b '{' class_items '}' ';'",
"class_name_b :",
"class_name_b : class_name_t",
"class_items : class_items class_item",
"class_items : class_item",
"class_item : class_name",
"class_item : class_ping_time",
"class_item : class_number_per_ip",
"class_item : class_connectfreq",
"class_item : class_max_number",
"class_item : class_max_global",
"class_item : class_max_local",
"class_item : class_max_ident",
"class_item : class_sendq",
"class_item : error",
"class_name : NAME '=' QSTRING ';'",
"class_name_t : QSTRING",
"class_ping_time : PING_TIME '=' timespec ';'",
"class_number_per_ip : NUMBER_PER_IP '=' NUMBER ';'",
"class_connectfreq : CONNECTFREQ '=' timespec ';'",
"class_max_number : MAX_NUMBER '=' NUMBER ';'",
"class_max_global : MAX_GLOBAL '=' NUMBER ';'",
"class_max_local : MAX_LOCAL '=' NUMBER ';'",
"class_max_ident : MAX_IDENT '=' NUMBER ';'",
"class_sendq : SENDQ '=' sizespec ';'",
"$$4 :",
"listen_entry : LISTEN $$4 '{' listen_items '}' ';'",
"listen_items : listen_items listen_item",
"listen_items : listen_item",
"listen_item : listen_port",
"listen_item : listen_address",
"listen_item : listen_host",
"listen_item : error",
"listen_port : PORT '=' port_items ';'",
"port_items : port_items ',' port_item",
"port_items : port_item",
"port_item : NUMBER",
"port_item : NUMBER TWODOTS NUMBER",
"listen_address : IP '=' QSTRING ';'",
"listen_host : HOST '=' QSTRING ';'",
"$$5 :",
"auth_entry : IRCD_AUTH $$5 '{' auth_items '}' ';'",
"auth_items : auth_items auth_item",
"auth_items : auth_item",
"auth_item : auth_user",
"auth_item : auth_passwd",
"auth_item : auth_class",
"auth_item : auth_flags",
"auth_item : auth_kline_exempt",
"auth_item : auth_need_ident",
"auth_item : auth_exceed_limit",
"auth_item : auth_no_tilde",
"auth_item : auth_gline_exempt",
"auth_item : auth_spoof",
"auth_item : auth_spoof_notice",
"auth_item : auth_redir_serv",
"auth_item : auth_redir_port",
"auth_item : auth_can_flood",
"auth_item : auth_need_password",
"auth_item : error",
"auth_user : USER '=' QSTRING ';'",
"auth_passwd : PASSWORD '=' QSTRING ';'",
"auth_spoof_notice : SPOOF_NOTICE '=' TBOOL ';'",
"auth_class : CLASS '=' QSTRING ';'",
"$$6 :",
"auth_flags : IRCD_FLAGS $$6 '=' auth_flags_items ';'",
"auth_flags_items : auth_flags_items ',' auth_flags_item",
"auth_flags_items : auth_flags_item",
"auth_flags_item : NOT auth_flags_item_atom",
"auth_flags_item : auth_flags_item_atom",
"auth_flags_item_atom : SPOOF_NOTICE",
"auth_flags_item_atom : EXCEED_LIMIT",
"auth_flags_item_atom : KLINE_EXEMPT",
"auth_flags_item_atom : NEED_IDENT",
"auth_flags_item_atom : CAN_FLOOD",
"auth_flags_item_atom : CAN_IDLE",
"auth_flags_item_atom : NO_TILDE",
"auth_flags_item_atom : GLINE_EXEMPT",
"auth_flags_item_atom : RESV_EXEMPT",
"auth_flags_item_atom : NEED_PASSWORD",
"auth_kline_exempt : KLINE_EXEMPT '=' TBOOL ';'",
"auth_need_ident : NEED_IDENT '=' TBOOL ';'",
"auth_exceed_limit : EXCEED_LIMIT '=' TBOOL ';'",
"auth_can_flood : CAN_FLOOD '=' TBOOL ';'",
"auth_no_tilde : NO_TILDE '=' TBOOL ';'",
"auth_gline_exempt : GLINE_EXEMPT '=' TBOOL ';'",
"auth_spoof : SPOOF '=' QSTRING ';'",
"auth_redir_serv : REDIRSERV '=' QSTRING ';'",
"auth_redir_port : REDIRPORT '=' NUMBER ';'",
"auth_need_password : NEED_PASSWORD '=' TBOOL ';'",
"$$7 :",
"resv_entry : RESV $$7 '{' resv_items '}' ';'",
"resv_items : resv_items resv_item",
"resv_items : resv_item",
"resv_item : resv_creason",
"resv_item : resv_channel",
"resv_item : resv_nick",
"resv_item : error",
"resv_creason : REASON '=' QSTRING ';'",
"resv_channel : CHANNEL '=' QSTRING ';'",
"resv_nick : NICK '=' QSTRING ';'",
"$$8 :",
"shared_entry : T_SHARED $$8 '{' shared_items '}' ';'",
"shared_items : shared_items shared_item",
"shared_items : shared_item",
"shared_item : shared_name",
"shared_item : shared_user",
"shared_item : shared_type",
"shared_item : error",
"shared_name : NAME '=' QSTRING ';'",
"shared_user : USER '=' QSTRING ';'",
"$$9 :",
"shared_type : TYPE $$9 '=' shared_types ';'",
"shared_types : shared_types ',' shared_type_item",
"shared_types : shared_type_item",
"shared_type_item : KLINE",
"shared_type_item : UNKLINE",
"shared_type_item : XLINE",
"shared_type_item : T_UNXLINE",
"shared_type_item : RESV",
"shared_type_item : T_UNRESV",
"shared_type_item : T_ALL",
"$$10 :",
"cluster_entry : T_CLUSTER $$10 '{' cluster_items '}' ';'",
"cluster_items : cluster_items cluster_item",
"cluster_items : cluster_item",
"cluster_item : cluster_name",
"cluster_item : cluster_type",
"cluster_item : error",
"cluster_name : NAME '=' QSTRING ';'",
"$$11 :",
"cluster_type : TYPE $$11 '=' cluster_types ';'",
"cluster_types : cluster_types ',' cluster_type_item",
"cluster_types : cluster_type_item",
"cluster_type_item : KLINE",
"cluster_type_item : UNKLINE",
"cluster_type_item : XLINE",
"cluster_type_item : T_UNXLINE",
"cluster_type_item : RESV",
"cluster_type_item : T_UNRESV",
"cluster_type_item : T_LOCOPS",
"cluster_type_item : T_ALL",
"$$12 :",
"connect_entry : CONNECT $$12 connect_name_b '{' connect_items '}' ';'",
"connect_name_b :",
"connect_name_b : connect_name_t",
"connect_items : connect_items connect_item",
"connect_items : connect_item",
"connect_item : connect_name",
"connect_item : connect_host",
"connect_item : connect_send_password",
"connect_item : connect_accept_password",
"connect_item : connect_port",
"connect_item : connect_aftype",
"connect_item : connect_fakename",
"connect_item : connect_flags",
"connect_item : connect_hub_mask",
"connect_item : connect_leaf_mask",
"connect_item : connect_class",
"connect_item : connect_auto",
"connect_item : connect_encrypted",
"connect_item : connect_compressed",
"connect_item : connect_cryptlink",
"connect_item : connect_rsa_public_key_file",
"connect_item : connect_cipher_preference",
"connect_item : error",
"connect_name : NAME '=' QSTRING ';'",
"connect_name_t : QSTRING",
"connect_host : HOST '=' QSTRING ';'",
"connect_send_password : SEND_PASSWORD '=' QSTRING ';'",
"connect_accept_password : ACCEPT_PASSWORD '=' QSTRING ';'",
"connect_port : PORT '=' NUMBER ';'",
"connect_aftype : AFTYPE '=' T_IPV4 ';'",
"connect_aftype : AFTYPE '=' T_IPV6 ';'",
"connect_fakename : FAKENAME '=' QSTRING ';'",
"$$13 :",
"connect_flags : IRCD_FLAGS $$13 '=' connect_flags_items ';'",
"connect_flags_items : connect_flags_items ',' connect_flags_item",
"connect_flags_items : connect_flags_item",
"connect_flags_item : LAZYLINK",
"connect_flags_item : COMPRESSED",
"connect_flags_item : CRYPTLINK",
"connect_flags_item : AUTOCONN",
"connect_flags_item : BURST_AWAY",
"connect_rsa_public_key_file : RSA_PUBLIC_KEY_FILE '=' QSTRING ';'",
"connect_encrypted : ENCRYPTED '=' TBOOL ';'",
"connect_cryptlink : CRYPTLINK '=' TBOOL ';'",
"connect_compressed : COMPRESSED '=' TBOOL ';'",
"connect_auto : AUTOCONN '=' TBOOL ';'",
"connect_hub_mask : HUB_MASK '=' QSTRING ';'",
"connect_leaf_mask : LEAF_MASK '=' QSTRING ';'",
"connect_class : CLASS '=' QSTRING ';'",
"connect_cipher_preference : CIPHER_PREFERENCE '=' QSTRING ';'",
"$$14 :",
"kill_entry : KILL $$14 '{' kill_items '}' ';'",
"kill_items : kill_items kill_item",
"kill_items : kill_item",
"kill_item : kill_user",
"kill_item : kill_reason",
"kill_item : error",
"kill_user : USER '=' QSTRING ';'",
"kill_reason : REASON '=' QSTRING ';'",
"$$15 :",
"deny_entry : DENY $$15 '{' deny_items '}' ';'",
"deny_items : deny_items deny_item",
"deny_items : deny_item",
"deny_item : deny_ip",
"deny_item : deny_reason",
"deny_item : error",
"deny_ip : IP '=' QSTRING ';'",
"deny_reason : REASON '=' QSTRING ';'",
"$$16 :",
"exempt_entry : EXEMPT $$16 '{' exempt_items '}' ';'",
"exempt_items : exempt_items exempt_item",
"exempt_items : exempt_item",
"exempt_item : exempt_ip",
"exempt_item : error",
"exempt_ip : IP '=' QSTRING ';'",
"$$17 :",
"gecos_entry : GECOS $$17 '{' gecos_items '}' ';'",
"gecos_items : gecos_items gecos_item",
"gecos_items : gecos_item",
"gecos_item : gecos_name",
"gecos_item : gecos_reason",
"gecos_item : error",
"gecos_name : NAME '=' QSTRING ';'",
"gecos_reason : REASON '=' QSTRING ';'",
"general_entry : GENERAL '{' general_items '}' ';'",
"general_items : general_items general_item",
"general_items : general_item",
"general_item : general_hide_spoof_ips",
"general_item : general_ignore_bogus_ts",
"general_item : general_failed_oper_notice",
"general_item : general_anti_nick_flood",
"general_item : general_max_nick_time",
"general_item : general_max_nick_changes",
"general_item : general_max_accept",
"general_item : general_anti_spam_exit_message_time",
"general_item : general_ts_warn_delta",
"general_item : general_ts_max_delta",
"general_item : general_kill_chase_time_limit",
"general_item : general_kline_with_reason",
"general_item : general_kline_reason",
"general_item : general_warn_no_nline",
"general_item : general_dots_in_ident",
"general_item : general_stats_o_oper_only",
"general_item : general_stats_k_oper_only",
"general_item : general_pace_wait",
"general_item : general_stats_i_oper_only",
"general_item : general_pace_wait_simple",
"general_item : general_stats_P_oper_only",
"general_item : general_short_motd",
"general_item : general_no_oper_flood",
"general_item : general_true_no_oper_flood",
"general_item : general_oper_pass_resv",
"general_item : general_idletime",
"general_item : general_maximum_links",
"general_item : general_message_locale",
"general_item : general_oper_only_umodes",
"general_item : general_max_targets",
"general_item : general_use_egd",
"general_item : general_egdpool_path",
"general_item : general_oper_umodes",
"general_item : general_caller_id_wait",
"general_item : general_default_floodcount",
"general_item : general_min_nonwildcard",
"general_item : general_min_nonwildcard_simple",
"general_item : general_servlink_path",
"general_item : general_disable_remote_commands",
"general_item : general_default_cipher_preference",
"general_item : general_compression_level",
"general_item : general_client_flood",
"general_item : general_throttle_time",
"general_item : general_havent_read_conf",
"general_item : general_dot_in_ip6_addr",
"general_item : general_ping_cookie",
"general_item : general_disable_auth",
"general_item : general_burst_away",
"general_item : general_tkline_expire_notices",
"general_item : general_gline_min_cidr",
"general_item : general_gline_min_cidr6",
"general_item : error",
"general_gline_min_cidr : GLINE_MIN_CIDR '=' NUMBER ';'",
"general_gline_min_cidr6 : GLINE_MIN_CIDR6 '=' NUMBER ';'",
"general_burst_away : BURST_AWAY '=' TBOOL ';'",
"general_tkline_expire_notices : TKLINE_EXPIRE_NOTICES '=' TBOOL ';'",
"general_kill_chase_time_limit : KILL_CHASE_TIME_LIMIT '=' NUMBER ';'",
"general_hide_spoof_ips : HIDE_SPOOF_IPS '=' TBOOL ';'",
"general_ignore_bogus_ts : IGNORE_BOGUS_TS '=' TBOOL ';'",
"general_disable_remote_commands : DISABLE_REMOTE_COMMANDS '=' TBOOL ';'",
"general_failed_oper_notice : FAILED_OPER_NOTICE '=' TBOOL ';'",
"general_anti_nick_flood : ANTI_NICK_FLOOD '=' TBOOL ';'",
"general_max_nick_time : MAX_NICK_TIME '=' timespec ';'",
"general_max_nick_changes : MAX_NICK_CHANGES '=' NUMBER ';'",
"general_max_accept : MAX_ACCEPT '=' NUMBER ';'",
"general_anti_spam_exit_message_time : ANTI_SPAM_EXIT_MESSAGE_TIME '=' timespec ';'",
"general_ts_warn_delta : TS_WARN_DELTA '=' timespec ';'",
"general_ts_max_delta : TS_MAX_DELTA '=' timespec ';'",
"general_havent_read_conf : HAVENT_READ_CONF '=' NUMBER ';'",
"general_kline_with_reason : KLINE_WITH_REASON '=' TBOOL ';'",
"general_kline_reason : KLINE_REASON '=' QSTRING ';'",
"general_warn_no_nline : WARN_NO_NLINE '=' TBOOL ';'",
"general_stats_o_oper_only : STATS_O_OPER_ONLY '=' TBOOL ';'",
"general_stats_P_oper_only : STATS_P_OPER_ONLY '=' TBOOL ';'",
"general_stats_k_oper_only : STATS_K_OPER_ONLY '=' TBOOL ';'",
"general_stats_k_oper_only : STATS_K_OPER_ONLY '=' TMASKED ';'",
"general_stats_i_oper_only : STATS_I_OPER_ONLY '=' TBOOL ';'",
"general_stats_i_oper_only : STATS_I_OPER_ONLY '=' TMASKED ';'",
"general_pace_wait : PACE_WAIT '=' timespec ';'",
"general_caller_id_wait : CALLER_ID_WAIT '=' timespec ';'",
"general_pace_wait_simple : PACE_WAIT_SIMPLE '=' timespec ';'",
"general_short_motd : SHORT_MOTD '=' TBOOL ';'",
"general_no_oper_flood : NO_OPER_FLOOD '=' TBOOL ';'",
"general_true_no_oper_flood : TRUE_NO_OPER_FLOOD '=' TBOOL ';'",
"general_oper_pass_resv : OPER_PASS_RESV '=' TBOOL ';'",
"general_message_locale : MESSAGE_LOCALE '=' QSTRING ';'",
"general_idletime : IDLETIME '=' timespec ';'",
"general_dots_in_ident : DOTS_IN_IDENT '=' NUMBER ';'",
"general_maximum_links : MAXIMUM_LINKS '=' NUMBER ';'",
"general_max_targets : MAX_TARGETS '=' NUMBER ';'",
"general_servlink_path : SERVLINK_PATH '=' QSTRING ';'",
"general_default_cipher_preference : DEFAULT_CIPHER_PREFERENCE '=' QSTRING ';'",
"general_compression_level : COMPRESSION_LEVEL '=' NUMBER ';'",
"general_use_egd : USE_EGD '=' TBOOL ';'",
"general_egdpool_path : EGDPOOL_PATH '=' QSTRING ';'",
"general_ping_cookie : PING_COOKIE '=' TBOOL ';'",
"general_disable_auth : DISABLE_AUTH '=' TBOOL ';'",
"general_throttle_time : THROTTLE_TIME '=' timespec ';'",
"$$18 :",
"general_oper_umodes : OPER_UMODES $$18 '=' umode_oitems ';'",
"umode_oitems : umode_oitems ',' umode_oitem",
"umode_oitems : umode_oitem",
"umode_oitem : T_BOTS",
"umode_oitem : T_CCONN",
"umode_oitem : T_DEBUG",
"umode_oitem : T_FULL",
"umode_oitem : T_SKILL",
"umode_oitem : T_NCHANGE",
"umode_oitem : T_REJ",
"umode_oitem : T_UNAUTH",
"umode_oitem : T_SPY",
"umode_oitem : T_EXTERNAL",
"umode_oitem : T_OPERWALL",
"umode_oitem : T_SERVNOTICE",
"umode_oitem : T_INVISIBLE",
"umode_oitem : T_WALLOP",
"umode_oitem : T_CALLERID",
"umode_oitem : T_LOCOPS",
"$$19 :",
"general_oper_only_umodes : OPER_ONLY_UMODES $$19 '=' umode_items ';'",
"umode_items : umode_items ',' umode_item",
"umode_items : umode_item",
"umode_item : T_BOTS",
"umode_item : T_CCONN",
"umode_item : T_DEBUG",
"umode_item : T_FULL",
"umode_item : T_SKILL",
"umode_item : T_NCHANGE",
"umode_item : T_REJ",
"umode_item : T_UNAUTH",
"umode_item : T_SPY",
"umode_item : T_EXTERNAL",
"umode_item : T_OPERWALL",
"umode_item : T_SERVNOTICE",
"umode_item : T_INVISIBLE",
"umode_item : T_WALLOP",
"umode_item : T_CALLERID",
"umode_item : T_LOCOPS",
"general_min_nonwildcard : MIN_NONWILDCARD '=' NUMBER ';'",
"general_min_nonwildcard_simple : MIN_NONWILDCARD_SIMPLE '=' NUMBER ';'",
"general_default_floodcount : DEFAULT_FLOODCOUNT '=' NUMBER ';'",
"general_client_flood : T_CLIENT_FLOOD '=' sizespec ';'",
"general_dot_in_ip6_addr : DOT_IN_IP6_ADDR '=' TBOOL ';'",
"$$20 :",
"gline_entry : GLINES $$20 '{' gline_items '}' ';'",
"gline_items : gline_items gline_item",
"gline_items : gline_item",
"gline_item : gline_enable",
"gline_item : gline_duration",
"gline_item : gline_logging",
"gline_item : gline_user",
"gline_item : gline_server",
"gline_item : gline_action",
"gline_item : error",
"gline_enable : ENABLE '=' TBOOL ';'",
"gline_duration : DURATION '=' timespec ';'",
"$$21 :",
"gline_logging : LOGGING $$21 '=' gline_logging_types ';'",
"gline_logging_types : gline_logging_types ',' gline_logging_type_item",
"gline_logging_types : gline_logging_type_item",
"gline_logging_type_item : T_REJECT",
"gline_logging_type_item : T_BLOCK",
"gline_user : USER '=' QSTRING ';'",
"gline_server : NAME '=' QSTRING ';'",
"$$22 :",
"gline_action : ACTION $$22 '=' gdeny_types ';'",
"gdeny_types : gdeny_types ',' gdeny_type_item",
"gdeny_types : gdeny_type_item",
"gdeny_type_item : T_REJECT",
"gdeny_type_item : T_BLOCK",
"channel_entry : CHANNEL '{' channel_items '}' ';'",
"channel_items : channel_items channel_item",
"channel_items : channel_item",
"channel_item : channel_disable_local_channels",
"channel_item : channel_use_except",
"channel_item : channel_use_invex",
"channel_item : channel_use_knock",
"channel_item : channel_max_bans",
"channel_item : channel_knock_delay",
"channel_item : channel_knock_delay_channel",
"channel_item : channel_invite_ops_only",
"channel_item : channel_max_chans_per_user",
"channel_item : channel_quiet_on_ban",
"channel_item : channel_default_split_user_count",
"channel_item : channel_default_split_server_count",
"channel_item : channel_no_create_on_split",
"channel_item : channel_no_join_on_split",
"channel_item : error",
"channel_disable_local_channels : DISABLE_LOCAL_CHANNELS '=' TBOOL ';'",
"channel_use_except : USE_EXCEPT '=' TBOOL ';'",
"channel_use_invex : USE_INVEX '=' TBOOL ';'",
"channel_use_knock : USE_KNOCK '=' TBOOL ';'",
"channel_knock_delay : KNOCK_DELAY '=' timespec ';'",
"channel_knock_delay_channel : KNOCK_DELAY_CHANNEL '=' timespec ';'",
"channel_invite_ops_only : INVITE_OPS_ONLY '=' TBOOL ';'",
"channel_max_chans_per_user : MAX_CHANS_PER_USER '=' NUMBER ';'",
"channel_quiet_on_ban : QUIET_ON_BAN '=' TBOOL ';'",
"channel_max_bans : MAX_BANS '=' NUMBER ';'",
"channel_default_split_user_count : DEFAULT_SPLIT_USER_COUNT '=' NUMBER ';'",
"channel_default_split_server_count : DEFAULT_SPLIT_SERVER_COUNT '=' NUMBER ';'",
"channel_no_create_on_split : NO_CREATE_ON_SPLIT '=' TBOOL ';'",
"channel_no_join_on_split : NO_JOIN_ON_SPLIT '=' TBOOL ';'",
"serverhide_entry : SERVERHIDE '{' serverhide_items '}' ';'",
"serverhide_items : serverhide_items serverhide_item",
"serverhide_items : serverhide_item",
"serverhide_item : serverhide_flatten_links",
"serverhide_item : serverhide_hide_servers",
"serverhide_item : serverhide_links_delay",
"serverhide_item : serverhide_disable_hidden",
"serverhide_item : serverhide_hidden",
"serverhide_item : serverhide_hide_server_ips",
"serverhide_item : error",
"serverhide_flatten_links : FLATTEN_LINKS '=' TBOOL ';'",
"serverhide_hide_servers : HIDE_SERVERS '=' TBOOL ';'",
"serverhide_links_delay : LINKS_DELAY '=' timespec ';'",
"serverhide_hidden : HIDDEN '=' TBOOL ';'",
"serverhide_disable_hidden : DISABLE_HIDDEN '=' TBOOL ';'",
"serverhide_hide_server_ips : HIDE_SERVER_IPS '=' TBOOL ';'",
};
#endif
#if YYDEBUG
#include <stdio.h>
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH 10000
#endif
#endif
#define YYINITSTACKSIZE 200
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short *yyss;
short *yysslim;
YYSTYPE *yyvs;
int yystacksize;
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack()
{
    int newsize, i;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;
    i = yyssp - yyss;
    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
      (short *)malloc(newsize * sizeof *newss);
    if (newss == NULL)
        return -1;
    yyss = newss;
    yyssp = newss + i;
    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
      (YYSTYPE *)malloc(newsize * sizeof *newvs);
    if (newvs == NULL)
        return -1;
    yyvs = newvs;
    yyvsp = newvs + i;
    yystacksize = newsize;
    yysslim = yyss + newsize - 1;
    return 0;
}

#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab

#ifndef YYPARSE_PARAM
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG void
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG
#define YYPARSE_PARAM_DECL
#endif	/* ANSI-C/C++ */
#else	/* YYPARSE_PARAM */
#ifndef YYPARSE_PARAM_TYPE
#define YYPARSE_PARAM_TYPE void *
#endif
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
#endif	/* ANSI-C/C++ */
#endif	/* ! YYPARSE_PARAM */

int
yyparse (YYPARSE_PARAM_ARG)
    YYPARSE_PARAM_DECL
{
    int yym, yyn, yystate;
#if YYDEBUG
    const char *yys;

    if ((yys = getenv("YYDEBUG")))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    if (yyss == NULL && yygrowstack()) goto yyoverflow;
    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if ((yyn = yydefred[yystate])) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yysslim && yygrowstack())
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#if defined(lint) || defined(__GNUC__)
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#if defined(lint) || defined(__GNUC__)
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yysslim && yygrowstack())
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 25:
#line 388 "ircd_parser.y"
{ yyval.number = 0; }
break;
case 27:
#line 390 "ircd_parser.y"
{
			yyval.number = yyvsp[-1].number + yyvsp[0].number;
		}
break;
case 28:
#line 394 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number + yyvsp[0].number;
		}
break;
case 29:
#line 398 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 + yyvsp[0].number;
		}
break;
case 30:
#line 402 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 * 60 + yyvsp[0].number;
		}
break;
case 31:
#line 406 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 * 60 * 24 + yyvsp[0].number;
		}
break;
case 32:
#line 410 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 * 60 * 24 * 7 + yyvsp[0].number;
		}
break;
case 33:
#line 415 "ircd_parser.y"
{ yyval.number = 0; }
break;
case 35:
#line 416 "ircd_parser.y"
{ yyval.number = yyvsp[-1].number + yyvsp[0].number; }
break;
case 36:
#line 417 "ircd_parser.y"
{ yyval.number = yyvsp[-2].number + yyvsp[0].number; }
break;
case 37:
#line 418 "ircd_parser.y"
{ yyval.number = yyvsp[-2].number * 1024 + yyvsp[0].number; }
break;
case 38:
#line 419 "ircd_parser.y"
{ yyval.number = yyvsp[-2].number * 1024 * 1024 + yyvsp[0].number; }
break;
case 45:
#line 433 "ircd_parser.y"
{
#ifndef STATIC_MODULES /* NOOP in the static case */
  if (ypass == 2)
  {
    char *m_bn;

    m_bn = basename(yylval.string);

    /* I suppose we should just ignore it if it is already loaded(since
     * otherwise we would flood the opers on rehash) -A1kmm.
     */
    add_conf_module(yylval.string);
  }
#endif
}
break;
case 46:
#line 450 "ircd_parser.y"
{
#ifndef STATIC_MODULES
  if (ypass == 2)
    mod_add_path(yylval.string);
#endif
}
break;
case 61:
#line 474 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    BIO *file;

    if (ServerInfo.rsa_private_key)
    {
      RSA_free(ServerInfo.rsa_private_key);
      ServerInfo.rsa_private_key = NULL;
    }

    if (ServerInfo.rsa_private_key_file)
    {
      MyFree(ServerInfo.rsa_private_key_file);
      ServerInfo.rsa_private_key_file = NULL;
    }

    DupString(ServerInfo.rsa_private_key_file, yylval.string);

    if ((file = BIO_new_file(yylval.string, "r")) == NULL)
    {
      yyerror("Ignoring config file entry rsa_private_key -- file open failed");
      break;
    }

    ServerInfo.rsa_private_key = (RSA *)PEM_read_bio_RSAPrivateKey(file, NULL, 0, NULL);

    if (ServerInfo.rsa_private_key == NULL)
    {
      yyerror("Ignoring config file entry rsa_private_key -- "
              "couldn't extract key");
      break;
    }

    if (!RSA_check_key(ServerInfo.rsa_private_key))
    {
      yyerror("Ignoring config file entry rsa_private_key -- invalid key");
      break;
    }

    /* require 2048 bit (256 byte) key */
    if (RSA_size(ServerInfo.rsa_private_key) != 256)
    {
      yyerror("Ignoring config file entry rsa_private_key -- not 2048 bit");
      break;
    }

    BIO_set_close(file, BIO_CLOSE);
    BIO_free(file);
  }
#endif
}
break;
case 62:
#line 529 "ircd_parser.y"
{
  /* this isn't rehashable */
  if (ypass == 2)
  {
    if (ServerInfo.name == NULL)
    {
      /* the ircd will exit() in main() if we dont set one */
      if (strlen(yylval.string) <= HOSTLEN)
        DupString(ServerInfo.name, yylval.string);
    }
  }
}
break;
case 63:
#line 543 "ircd_parser.y"
{
  /* this isn't rehashable */
  if (ypass == 2 && !ServerInfo.sid)
  {
    if ((strlen(yylval.string) == IRC_MAXSID) && IsDigit(yylval.string[0])
	&& IsAlNum(yylval.string[1]) && IsAlNum(yylval.string[2]))
    {
      DupString(ServerInfo.sid, yylval.string);
    }
    else
    {
      ilog(L_ERROR, "Ignoring config file entry SID -- invalid SID. Aborting.");
      exit(0);
    }
  }
}
break;
case 64:
#line 561 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ServerInfo.description);
    DupString(ServerInfo.description,yylval.string);
  }
}
break;
case 65:
#line 570 "ircd_parser.y"
{
  if (ypass == 2)
  {
    char *p;

    if ((p = strchr(yylval.string, ' ')) != NULL)
      p = '\0';

    MyFree(ServerInfo.network_name);
    DupString(ServerInfo.network_name, yylval.string);
  }
}
break;
case 66:
#line 584 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ServerInfo.network_desc);
    DupString(ServerInfo.network_desc, yylval.string);
  }
}
break;
case 67:
#line 593 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct addrinfo hints, *res;

    memset(&hints, 0, sizeof(hints));

    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE | AI_NUMERICHOST;

    if (irc_getaddrinfo(yylval.string, NULL, &hints, &res))
      ilog(L_ERROR, "Invalid netmask for server vhost(%s)", yylval.string);
    else
    {
      assert(res != NULL);

      memcpy(&ServerInfo.ip, res->ai_addr, res->ai_addrlen);
      ServerInfo.ip.ss.ss_family = res->ai_family;
      ServerInfo.ip.ss_len = res->ai_addrlen;
      irc_freeaddrinfo(res);

      ServerInfo.specific_ipv4_vhost = 1;
    }
  }
}
break;
case 68:
#line 621 "ircd_parser.y"
{
#ifdef IPV6
  if (ypass == 2)
  {
    struct addrinfo hints, *res;

    memset(&hints, 0, sizeof(hints));

    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE | AI_NUMERICHOST;

    if (irc_getaddrinfo(yylval.string, NULL, &hints, &res))
      ilog(L_ERROR, "Invalid netmask for server vhost6(%s)", yylval.string);
    else
    {
      assert(res != NULL);

      memcpy(&ServerInfo.ip6, res->ai_addr, res->ai_addrlen);
      ServerInfo.ip6.ss.ss_family = res->ai_family;
      ServerInfo.ip6.ss_len = res->ai_addrlen;
      irc_freeaddrinfo(res);

      ServerInfo.specific_ipv6_vhost = 1;
    }
  }
#endif
}
break;
case 69:
#line 651 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (MAXCONN >= yyvsp[-1].number)
    {
      ServerInfo.max_clients = yyvsp[-1].number;
    }
    else
    {
      ilog(L_ERROR, "Setting serverinfo_max_clients to MAXCONN");
      ServerInfo.max_clients = MAXCONN;
    }
  }
}
break;
case 70:
#line 667 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
    {
      /* Don't become a hub if we have a lazylink active. */
      if (!ServerInfo.hub && uplink && IsCapable(uplink, CAP_LL))
      {
        sendto_realops_flags(UMODE_ALL, L_ALL,
                             "Ignoring config file line hub=yes; "
                             "due to active LazyLink (%s)", uplink->name);
      }
      else
      {
        ServerInfo.hub = 1;
        uplink = NULL;
        delete_capability("HUB");
        add_capability("HUB", CAP_HUB, 1);
      }
    }
    else if (ServerInfo.hub)
    {
      dlink_node *ptr;

      ServerInfo.hub = 0;
      delete_capability("HUB");

      /* Don't become a leaf if we have a lazylink active. */
      DLINK_FOREACH(ptr, serv_list.head)
      {
        if (MyConnect((struct Client *)ptr->data) &&
            IsCapable((struct Client *)ptr->data, CAP_LL))
        {
          sendto_realops_flags(UMODE_ALL, L_ALL,
                               "Ignoring config file line hub=no; "
                               "due to active LazyLink (%s)",
                               ((struct Client *)ptr->data)->name);
          add_capability("HUB", CAP_HUB, 1);
          ServerInfo.hub = 1;
          break;
        }
      }
    }
  }
}
break;
case 78:
#line 723 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(AdminInfo.name);
    DupString(AdminInfo.name, yylval.string);
  }
}
break;
case 79:
#line 732 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(AdminInfo.email);
    DupString(AdminInfo.email, yylval.string);
  }
}
break;
case 80:
#line 741 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(AdminInfo.description);
    DupString(AdminInfo.description, yylval.string);
  }
}
break;
case 93:
#line 764 "ircd_parser.y"
{
                        }
break;
case 94:
#line 768 "ircd_parser.y"
{
                        }
break;
case 95:
#line 772 "ircd_parser.y"
{
                        }
break;
case 96:
#line 776 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.userlog, yylval.string,
            sizeof(ConfigLoggingEntry.userlog));
}
break;
case 97:
#line 783 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.failed_operlog, yylval.string,
            sizeof(ConfigLoggingEntry.failed_operlog));
}
break;
case 98:
#line 790 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.operlog, yylval.string,
            sizeof(ConfigLoggingEntry.operlog));
}
break;
case 99:
#line 797 "ircd_parser.y"
{ 
  if (ypass == 2)
    set_log_level(L_CRIT);
}
break;
case 100:
#line 801 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_ERROR);
}
break;
case 101:
#line 805 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_WARN);
}
break;
case 102:
#line 809 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_NOTICE);
}
break;
case 103:
#line 813 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_TRACE);
}
break;
case 104:
#line 817 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_INFO);
}
break;
case 105:
#line 821 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_DEBUG);
}
break;
case 106:
#line 827 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigLoggingEntry.use_logging = yylval.number;
}
break;
case 107:
#line 836 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(OPER_TYPE);
    yy_aconf = (struct AccessItem *)map_to_conf(yy_conf);
  }
  else
  {
    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 108:
#line 848 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;
    dlink_node *ptr;
    dlink_node *next_ptr;

    conf_add_class_to_conf(yy_conf, class_name);

    /* Now, make sure there is a copy of the "base" given oper
     * block in each of the collected copies
     */

    DLINK_FOREACH_SAFE(ptr, next_ptr, col_conf_list.head)
    {
      struct AccessItem *new_aconf;
      struct ConfItem *new_conf;
      yy_tmp = ptr->data;

      new_conf = make_conf_item(OPER_TYPE);
      new_aconf = (struct AccessItem *)map_to_conf(new_conf);

      new_aconf->flags = yy_aconf->flags;

      if (yy_conf->name != NULL)
        DupString(new_conf->name, yy_conf->name);
      if (yy_tmp->user != NULL)
	DupString(new_aconf->user, yy_tmp->user);
      else
	DupString(new_aconf->user, "*");
      if (yy_tmp->host != NULL)
	DupString(new_aconf->host, yy_tmp->host);
      else
	DupString(new_aconf->host, "*");
      conf_add_class_to_conf(new_conf, class_name);
      if (yy_aconf->passwd != NULL)
        DupString(new_aconf->passwd, yy_aconf->passwd);

      new_aconf->port = yy_aconf->port;
#ifdef HAVE_LIBCRYPTO
      if (yy_aconf->rsa_public_key_file != NULL)
      {
        BIO *file;

        DupString(new_aconf->rsa_public_key_file,
		  yy_aconf->rsa_public_key_file);

        file = BIO_new_file(yy_aconf->rsa_public_key_file, "r");
        new_aconf->rsa_public_key = (RSA *)PEM_read_bio_RSA_PUBKEY(file, 
							   NULL, 0, NULL);
        BIO_set_close(file, BIO_CLOSE);
        BIO_free(file);
      }
#endif

#ifdef HAVE_LIBCRYPTO
      if (yy_tmp->name && (yy_tmp->passwd || yy_aconf->rsa_public_key)
	  && yy_tmp->host)
#else
      if (yy_tmp->name && yy_tmp->passwd && yy_tmp->host)
#endif
      {
        conf_add_class_to_conf(new_conf, class_name);
	if (yy_tmp->name != NULL)
	  DupString(new_conf->name, yy_tmp->name);
      }

      dlinkDelete(&yy_tmp->node, &col_conf_list);
      free_collect_item(yy_tmp);
    }

    yy_conf = NULL;
    yy_aconf = NULL;


    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 132:
#line 939 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (strlen(yylval.string) > OPERNICKLEN)
      yylval.string[OPERNICKLEN] = '\0';

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 133:
#line 951 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (strlen(yylval.string) > OPERNICKLEN)
      yylval.string[OPERNICKLEN] = '\0';

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 134:
#line 963 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;

    if (yy_aconf->user == NULL)
    {
      DupString(yy_aconf->host, yylval.string);
      split_user_host(yy_aconf->host, &yy_aconf->user, &yy_aconf->host);
    }
    else
    {
      yy_tmp = (struct CollectItem *)MyMalloc(sizeof(struct CollectItem));

      DupString(yy_tmp->host, yylval.string);
      split_user_host(yy_tmp->host, &yy_tmp->user, &yy_tmp->host);

      dlinkAdd(yy_tmp, &yy_tmp->node, &col_conf_list);
    }
  }
}
break;
case 135:
#line 986 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_aconf->passwd != NULL)
      memset(yy_aconf->passwd, 0, strlen(yy_aconf->passwd));

    MyFree(yy_aconf->passwd);
    DupString(yy_aconf->passwd, yylval.string);
  }
}
break;
case 136:
#line 998 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_ENCRYPTED;
    else
      yy_aconf->flags &= ~CONF_FLAGS_ENCRYPTED;
  }
}
break;
case 137:
#line 1009 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_HIDDEN_ADMIN;
    else
      yy_aconf->port &= ~OPER_FLAG_HIDDEN_ADMIN;
  }
}
break;
case 138:
#line 1020 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    BIO *file;

    if (yy_aconf->rsa_public_key != NULL)
    {
      RSA_free(yy_aconf->rsa_public_key);
      yy_aconf->rsa_public_key = NULL;
    }

    if (yy_aconf->rsa_public_key_file != NULL)
    {
      MyFree(yy_aconf->rsa_public_key_file);
      yy_aconf->rsa_public_key_file = NULL;
    }

    DupString(yy_aconf->rsa_public_key_file, yylval.string);
    file = BIO_new_file(yylval.string, "r");

    if (file == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- file doesn't exist");
      break;
    }

    yy_aconf->rsa_public_key = (RSA *)PEM_read_bio_RSA_PUBKEY(file, NULL, 0, NULL);

    if (yy_aconf->rsa_public_key == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- Key invalid; check key syntax.");
      break;
    }

    BIO_set_close(file, BIO_CLOSE);
    BIO_free(file);
  }
#endif /* HAVE_LIBCRYPTO */
}
break;
case 139:
#line 1062 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(class_name);
    DupString(class_name, yylval.string);
  }
}
break;
case 140:
#line 1071 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_GLOBAL_KILL;
    else
      yy_aconf->port &= ~OPER_FLAG_GLOBAL_KILL;
  }
}
break;
case 141:
#line 1082 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_REMOTE;
    else
      yy_aconf->port &= ~OPER_FLAG_REMOTE; 
  }
}
break;
case 142:
#line 1093 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_K;
    else
      yy_aconf->port &= ~OPER_FLAG_K;
  }
}
break;
case 143:
#line 1104 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_X;
    else
      yy_aconf->port &= ~OPER_FLAG_X;
  }
}
break;
case 144:
#line 1115 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_UNKLINE;
    else
      yy_aconf->port &= ~OPER_FLAG_UNKLINE; 
  }
}
break;
case 145:
#line 1126 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_GLINE;
    else
      yy_aconf->port &= ~OPER_FLAG_GLINE;
  }
}
break;
case 146:
#line 1137 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_N;
    else
      yy_aconf->port &= ~OPER_FLAG_N;
  }
}
break;
case 147:
#line 1148 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_DIE;
    else
      yy_aconf->port &= ~OPER_FLAG_DIE;
  }
}
break;
case 148:
#line 1159 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_REHASH;
    else
      yy_aconf->port &= ~OPER_FLAG_REHASH;
  }
}
break;
case 149:
#line 1170 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_ADMIN;
    else
      yy_aconf->port &= ~OPER_FLAG_ADMIN;
  }
}
break;
case 150:
#line 1181 "ircd_parser.y"
{
}
break;
case 154:
#line 1185 "ircd_parser.y"
{ not_atom = 1; }
break;
case 155:
#line 1186 "ircd_parser.y"
{ not_atom = 0; }
break;
case 156:
#line 1189 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)yy_aconf->port &= ~OPER_FLAG_GLOBAL_KILL;
    else yy_aconf->port |= OPER_FLAG_GLOBAL_KILL;
  }
}
break;
case 157:
#line 1196 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_REMOTE;
    else yy_aconf->port |= OPER_FLAG_REMOTE;
  }
}
break;
case 158:
#line 1203 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_K;
    else yy_aconf->port |= OPER_FLAG_K;
  }
}
break;
case 159:
#line 1210 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_UNKLINE;
    else yy_aconf->port |= OPER_FLAG_UNKLINE;
  } 
}
break;
case 160:
#line 1217 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_X;
    else yy_aconf->port |= OPER_FLAG_X;
  }
}
break;
case 161:
#line 1224 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_GLINE;
    else yy_aconf->port |= OPER_FLAG_GLINE;
  }
}
break;
case 162:
#line 1231 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_DIE;
    else yy_aconf->port |= OPER_FLAG_DIE;
  }
}
break;
case 163:
#line 1238 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_REHASH;
    else yy_aconf->port |= OPER_FLAG_REHASH;
  }
}
break;
case 164:
#line 1245 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_ADMIN;
    else yy_aconf->port |= OPER_FLAG_ADMIN;
  }
}
break;
case 165:
#line 1252 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_HIDDEN_ADMIN;
    else yy_aconf->port |= OPER_FLAG_HIDDEN_ADMIN;
  }
}
break;
case 166:
#line 1259 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_N;
    else yy_aconf->port |= OPER_FLAG_N;
  }
}
break;
case 167:
#line 1266 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_OPERWALL;
    else yy_aconf->port |= OPER_FLAG_OPERWALL;
  }
}
break;
case 168:
#line 1273 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_OPER_SPY;
    else yy_aconf->port |= OPER_FLAG_OPER_SPY;
  }
}
break;
case 169:
#line 1280 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_HIDDEN_OPER;
    else yy_aconf->port |= OPER_FLAG_HIDDEN_OPER;
  }
}
break;
case 170:
#line 1287 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_REMOTEBAN;
    else yy_aconf->port |= OPER_FLAG_REMOTEBAN;
  }
}
break;
case 171:
#line 1300 "ircd_parser.y"
{
  if (ypass == 1)
  {
    yy_conf = make_conf_item(CLASS_TYPE);
    yy_class = (struct ClassItem *)map_to_conf(yy_conf);
  }
}
break;
case 172:
#line 1307 "ircd_parser.y"
{
  if (ypass == 1)
  {
    if ((yy_conf != NULL) && (yy_conf->name == NULL))
    {
      delete_conf_item(yy_conf);
      yy_conf = NULL;
      yy_class = NULL;
    }
  }
}
break;
case 187:
#line 1334 "ircd_parser.y"
{
  if (ypass == 1)
  {
    struct ConfItem *cconf = find_exact_name_conf(CLASS_TYPE, yylval.string,
                                                  NULL, NULL);
    struct ClassItem *class = NULL;

    if (cconf != NULL)
    {
      if (cconf == yy_conf)
        cconf = NULL;
      else
        class = (struct ClassItem *) map_to_conf(cconf);
    }

    if (class != NULL && MaxTotal(class) >= 0)
    {
      yyerror("Multiple classes with the same name, using the first entry");
      MyFree(yy_conf->name);
      yy_conf->name = NULL;
    }
    else
    {
      if (class != NULL)
      {
        PingFreq(class) = PingFreq(yy_class);
        MaxPerIp(class) = MaxPerIp(yy_class);
        ConFreq(class) = ConFreq(yy_class);
        MaxTotal(class) = MaxTotal(yy_class);
        MaxGlobal(class) = MaxGlobal(yy_class);
        MaxLocal(class) = MaxLocal(yy_class);
        MaxIdent(class) = MaxIdent(yy_class);
        MaxSendq(class) = MaxSendq(yy_class);
        delete_conf_item(yy_conf);
        yy_conf = cconf;
        yy_class = class;
        /* allow changing case - replace old name */
      }

      MyFree(yy_conf->name);
      DupString(yy_conf->name, yylval.string);
    }
  }
}
break;
case 188:
#line 1380 "ircd_parser.y"
{
  if (ypass == 1)
  {
    struct ConfItem *cconf = find_exact_name_conf(CLASS_TYPE, yylval.string,
                                                  NULL, NULL);
    struct ClassItem *class = NULL;

    if (cconf != NULL)
    {
      if (cconf == yy_conf)
        cconf = NULL;
      else
        class = (struct ClassItem *) map_to_conf(cconf);
    }

    if (class != NULL && MaxTotal(class) >= 0)
    {
      yyerror("Multiple classes with the same name, using the first entry");
      MyFree(yy_conf->name);
      yy_conf->name = NULL;
    }
    else
    {
      if (class != NULL)
      {
        PingFreq(class) = PingFreq(yy_class);
        MaxPerIp(class) = MaxPerIp(yy_class);
        ConFreq(class) = ConFreq(yy_class);
        MaxTotal(class) = MaxTotal(yy_class);
        MaxGlobal(class) = MaxGlobal(yy_class);
        MaxLocal(class) = MaxLocal(yy_class);
        MaxIdent(class) = MaxIdent(yy_class);
        MaxSendq(class) = MaxSendq(yy_class);
        delete_conf_item(yy_conf);
        yy_conf = cconf;
        yy_class = class;
        /* allow changing case - replace old name */
      }

      MyFree(yy_conf->name);
      DupString(yy_conf->name, yylval.string);
    }
  }
}
break;
case 189:
#line 1426 "ircd_parser.y"
{
  if (ypass == 1)
    PingFreq(yy_class) = yyvsp[-1].number;
}
break;
case 190:
#line 1432 "ircd_parser.y"
{
  if (ypass == 1)
    MaxPerIp(yy_class) = yyvsp[-1].number;
}
break;
case 191:
#line 1438 "ircd_parser.y"
{
  if (ypass == 1)
    ConFreq(yy_class) = yyvsp[-1].number;
}
break;
case 192:
#line 1444 "ircd_parser.y"
{
  if (ypass == 1)
    MaxTotal(yy_class) = yyvsp[-1].number;
}
break;
case 193:
#line 1450 "ircd_parser.y"
{
  if (ypass == 1)
    MaxGlobal(yy_class) = yyvsp[-1].number;
}
break;
case 194:
#line 1456 "ircd_parser.y"
{
  if (ypass == 1)
    MaxLocal(yy_class) = yyvsp[-1].number;
}
break;
case 195:
#line 1462 "ircd_parser.y"
{
  if (ypass == 1)
    MaxIdent(yy_class) = yyvsp[-1].number;
}
break;
case 196:
#line 1468 "ircd_parser.y"
{
  if (ypass == 1)
    MaxSendq(yy_class) = yyvsp[-1].number;
}
break;
case 197:
#line 1477 "ircd_parser.y"
{
  if (ypass == 2)
    listener_address = NULL;
}
break;
case 198:
#line 1481 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(listener_address);
    listener_address = NULL;
  }
}
break;
case 208:
#line 1497 "ircd_parser.y"
{
  if (ypass == 2)
    add_listener(yyvsp[0].number, listener_address);
}
break;
case 209:
#line 1501 "ircd_parser.y"
{
  if (ypass == 2)
  {
    int i;

    for (i = yyvsp[-2].number; i <= yyvsp[0].number; i++)
    {
      add_listener(i, listener_address);
    }
  }
}
break;
case 210:
#line 1514 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(listener_address);
    DupString(listener_address, yylval.string);
  }
}
break;
case 211:
#line 1523 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(listener_address);
    DupString(listener_address, yylval.string);
  }
}
break;
case 212:
#line 1535 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(CLIENT_TYPE);
    yy_aconf = map_to_conf(yy_conf);
  }
  else
  {
    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 213:
#line 1547 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;
    dlink_node *ptr;
    dlink_node *next_ptr;

    conf_add_class_to_conf(yy_conf, class_name);
    add_conf_by_address(CONF_CLIENT, yy_aconf);

    /* copy over settings from first struct */
    DLINK_FOREACH_SAFE(ptr, next_ptr, col_conf_list.head)
    {
      struct AccessItem *new_aconf;
      struct ConfItem *new_conf;

      new_conf = make_conf_item(CLIENT_TYPE);
      new_aconf = (struct AccessItem *)map_to_conf(new_conf);

      yy_tmp = ptr->data;

      if (yy_aconf->passwd != NULL)
        DupString(new_aconf->passwd, yy_aconf->passwd);
      if (yy_conf->name != NULL)
        DupString(new_conf->name, yy_conf->name);

      if (yy_aconf->passwd != NULL)
	DupString(new_aconf->passwd, yy_aconf->passwd);

      new_aconf->flags = yy_aconf->flags;
      new_aconf->port  = yy_aconf->port;

      if (yy_tmp->user != NULL)
      {
	DupString(new_aconf->user, yy_tmp->user);
        collapse(new_aconf->user);
      }
      else
        DupString(new_aconf->user, "*");

      if (yy_tmp->host != NULL)
      {
	DupString(new_aconf->host, yy_tmp->host);
        collapse(new_aconf->host);
      }
      else
	DupString(new_aconf->host, "*");

      conf_add_class_to_conf(new_conf, class_name);
      add_conf_by_address(CONF_CLIENT, new_aconf);
      dlinkDelete(&yy_tmp->node, &col_conf_list);
      free_collect_item(yy_tmp);
    }

    MyFree(class_name);
    class_name = NULL;
    yy_conf = NULL;
    yy_aconf = NULL;
  }
}
break;
case 232:
#line 1617 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;

    if (yy_aconf->user == NULL)
    {
      if (yylval.string != NULL)
      {
	DupString(yy_aconf->host, yylval.string);
	split_user_host(yy_aconf->host, &yy_aconf->user, &yy_aconf->host);
      }
    }
    else
    {
      yy_tmp = (struct CollectItem *)MyMalloc(sizeof(struct CollectItem));
      if (yylval.string != NULL)
      {
	DupString(yy_tmp->host, yylval.string);
	split_user_host(yy_tmp->host, &yy_tmp->user, &yy_tmp->host);
      }
      dlinkAdd(yy_tmp, &yy_tmp->node, &col_conf_list);
    }
  }
}
break;
case 233:
#line 1646 "ircd_parser.y"
{
  if (ypass == 2)
  {
    /* be paranoid */
    if (yy_aconf->passwd != NULL)
      memset(yy_aconf->passwd, 0, strlen(yy_aconf->passwd));

    MyFree(yy_aconf->passwd);
    DupString(yy_aconf->passwd, yylval.string);
  }
}
break;
case 234:
#line 1659 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_SPOOF_NOTICE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_SPOOF_NOTICE;
  }
}
break;
case 235:
#line 1670 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(class_name);
    DupString(class_name, yylval.string);
  }
}
break;
case 236:
#line 1679 "ircd_parser.y"
{
}
break;
case 240:
#line 1683 "ircd_parser.y"
{ not_atom = 1; }
break;
case 241:
#line 1684 "ircd_parser.y"
{ not_atom = 0; }
break;
case 242:
#line 1687 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_SPOOF_NOTICE;
    else yy_aconf->flags |= CONF_FLAGS_SPOOF_NOTICE;
  }

}
break;
case 243:
#line 1695 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NOLIMIT;
    else yy_aconf->flags |= CONF_FLAGS_NOLIMIT;
  }
}
break;
case 244:
#line 1702 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_EXEMPTKLINE;
    else yy_aconf->flags |= CONF_FLAGS_EXEMPTKLINE;
  } 
}
break;
case 245:
#line 1709 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NEED_IDENTD;
    else yy_aconf->flags |= CONF_FLAGS_NEED_IDENTD;
  }
}
break;
case 246:
#line 1716 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_CAN_FLOOD;
    else yy_aconf->flags |= CONF_FLAGS_CAN_FLOOD;
  }
}
break;
case 247:
#line 1723 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_IDLE_LINED;
    else yy_aconf->flags |= CONF_FLAGS_IDLE_LINED;
  }
}
break;
case 248:
#line 1730 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NO_TILDE;
    else yy_aconf->flags |= CONF_FLAGS_NO_TILDE;
  } 
}
break;
case 249:
#line 1737 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_EXEMPTGLINE;
    else yy_aconf->flags |= CONF_FLAGS_EXEMPTGLINE;
  } 
}
break;
case 250:
#line 1744 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_EXEMPTRESV;
    else yy_aconf->flags |= CONF_FLAGS_EXEMPTRESV;
  }
}
break;
case 251:
#line 1751 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NEED_PASSWORD;
    else yy_aconf->flags |= CONF_FLAGS_NEED_PASSWORD;
  }
}
break;
case 252:
#line 1760 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_EXEMPTKLINE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_EXEMPTKLINE;
  }
}
break;
case 253:
#line 1771 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NEED_IDENTD;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NEED_IDENTD;
  }
}
break;
case 254:
#line 1782 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NOLIMIT;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NOLIMIT;
  }
}
break;
case 255:
#line 1793 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_CAN_FLOOD;
    else
      yy_aconf->flags &= ~CONF_FLAGS_CAN_FLOOD;
  }
}
break;
case 256:
#line 1804 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NO_TILDE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NO_TILDE;
  }
}
break;
case 257:
#line 1815 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_EXEMPTGLINE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_EXEMPTGLINE;
  }
}
break;
case 258:
#line 1827 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_conf->name);

    if (strlen(yylval.string) < HOSTLEN)
    {    
      DupString(yy_conf->name, yylval.string);
      yy_aconf->flags |= CONF_FLAGS_SPOOF_IP;
    }
    else
    {
      ilog(L_ERROR, "Spoofs must be less than %d..ignoring it", HOSTLEN);
      yy_conf->name = NULL;
    }
  }
}
break;
case 259:
#line 1846 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_aconf->flags |= CONF_FLAGS_REDIR;
    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 260:
#line 1856 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_aconf->flags |= CONF_FLAGS_REDIR;
    yy_aconf->port = yyvsp[-1].number;
  }
}
break;
case 261:
#line 1865 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NEED_PASSWORD;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NEED_PASSWORD;
  }
}
break;
case 262:
#line 1880 "ircd_parser.y"
{
  if (ypass == 2)
    resv_reason = NULL;
}
break;
case 263:
#line 1884 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(resv_reason);
    resv_reason = NULL;
  }
}
break;
case 270:
#line 1896 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(resv_reason);
    DupString(resv_reason, yylval.string);
  }
}
break;
case 271:
#line 1905 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (IsChanPrefix(*yylval.string))
    {
      char def_reason[] = "No reason specified";

      create_channel_resv(yylval.string, resv_reason != NULL ? resv_reason : def_reason, 1);
    }
  }
  /* ignore it for now.. but we really should make a warning if
   * its an erroneous name --fl_ */
}
break;
case 272:
#line 1920 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (clean_resv_nick(yylval.string))
    {
      char def_reason[] = "No reason specified";

      create_nick_resv(yylval.string, resv_reason != NULL ? resv_reason : def_reason, 1);
    }
  }

  /* otherwise its erroneous, but ignore it for now */
}
break;
case 273:
#line 1938 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(ULINE_TYPE);
    yy_match_item = map_to_conf(yy_conf);
    yy_match_item->action = SHARED_ALL;
  }
}
break;
case 274:
#line 1946 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = NULL;
  }
}
break;
case 281:
#line 1957 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 282:
#line 1966 "ircd_parser.y"
{
  if (ypass == 2)
  {
    DupString(yy_match_item->user, yylval.string);
    split_user_host(yy_match_item->user, &yy_match_item->user, &yy_match_item->host);

    /* default to *@* */
    if (yy_match_item->user == NULL)
      DupString(yy_match_item->user, "*");
    if (yy_match_item->host == NULL)
      DupString(yy_match_item->host, "*");
  }
}
break;
case 283:
#line 1981 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action = 0;
}
break;
case 287:
#line 1988 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_KLINE;
}
break;
case 288:
#line 1992 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNKLINE;
}
break;
case 289:
#line 1996 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_XLINE;
}
break;
case 290:
#line 2000 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNXLINE;
}
break;
case 291:
#line 2004 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_RESV;
}
break;
case 292:
#line 2008 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNRESV;
}
break;
case 293:
#line 2012 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action = SHARED_ALL;
}
break;
case 294:
#line 2021 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(CLUSTER_TYPE);
    yy_match_item = (struct MatchItem *)map_to_conf(yy_conf);
    yy_match_item->action = CLUSTER_ALL;
  }
}
break;
case 295:
#line 2029 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_conf->name == NULL)
      DupString(yy_conf->name, "*");
    if (yy_match_item->user == NULL)
      DupString(yy_match_item->user, "*");
    if (yy_match_item->host == NULL)
      DupString(yy_match_item->host, "*");
    yy_conf = NULL;
  }
}
break;
case 301:
#line 2046 "ircd_parser.y"
{
  if (ypass == 2)
    DupString(yy_conf->name, yylval.string);
}
break;
case 302:
#line 2052 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action = 0;
}
break;
case 306:
#line 2059 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= CLUSTER_KLINE;
}
break;
case 307:
#line 2063 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= CLUSTER_UNKLINE;
}
break;
case 308:
#line 2067 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= CLUSTER_XLINE;
}
break;
case 309:
#line 2071 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= CLUSTER_UNXLINE;
}
break;
case 310:
#line 2075 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= CLUSTER_RESV;
}
break;
case 311:
#line 2079 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= CLUSTER_UNRESV;
}
break;
case 312:
#line 2083 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= CLUSTER_LOCOPS;
}
break;
case 313:
#line 2087 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action = CLUSTER_ALL;
}
break;
case 314:
#line 2096 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(SERVER_TYPE);
    yy_aconf = (struct AccessItem *)map_to_conf(yy_conf);
    yy_aconf->passwd = NULL;
    /* defaults */
    yy_aconf->port = PORTNUM;

    if (ConfigFileEntry.burst_away)
      yy_aconf->flags = CONF_FLAGS_BURST_AWAY;
  }
  else
  {
    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 315:
#line 2114 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_hconf=NULL;
    struct CollectItem *yy_lconf=NULL;
    dlink_node *ptr;
    dlink_node *next_ptr;
#ifdef HAVE_LIBCRYPTO
    if (yy_aconf->host &&
	((yy_aconf->passwd && yy_aconf->spasswd) ||
	 (yy_aconf->rsa_public_key && IsConfCryptLink(yy_aconf))))
#else /* !HAVE_LIBCRYPTO */
      if (yy_aconf->host && !IsConfCryptLink(yy_aconf) && 
	  yy_aconf->passwd && yy_aconf->spasswd)
#endif /* !HAVE_LIBCRYPTO */
	{
	  if (conf_add_server(yy_conf, scount, class_name) >= 0)
	  {
	    ++scount;
	  }
	  else
	  {
	    delete_conf_item(yy_conf);
	    yy_conf = NULL;
	    yy_aconf = NULL;
	  }
	}
	else
	{
	  /* Even if yy_conf ->name is NULL
	   * should still unhook any hub/leaf confs still pending
	   */
	  unhook_hub_leaf_confs();

	  if (yy_conf->name != NULL)
	  {
#ifndef HAVE_LIBCRYPTO
	    if (IsConfCryptLink(yy_aconf))
	      yyerror("Ignoring connect block -- no OpenSSL support");
#else
	    if (IsConfCryptLink(yy_aconf) && !yy_aconf->rsa_public_key)
	      yyerror("Ignoring connect block -- missing key");
#endif
	    if (yy_aconf->host == NULL)
	      yyerror("Ignoring connect block -- missing host");
	    else if (!IsConfCryptLink(yy_aconf) && 
		    (!yy_aconf->passwd || !yy_aconf->spasswd))
              yyerror("Ignoring connect block -- missing password");
	  }


          /* XXX
           * This fixes a try_connections() core (caused by invalid class_ptr
           * pointers) reported by metalrock. That's an ugly fix, but there
           * is currently no better way. The entire config subsystem needs an
           * rewrite ASAP. make_conf_item() shouldn't really add things onto
           * a doubly linked list immediately without any sanity checks!  -Michael
           */
          delete_conf_item(yy_conf);

          yy_aconf = NULL;
	  yy_conf = NULL;
	}

      /*
       * yy_conf is still pointing at the server that is having
       * a connect block built for it. This means, y_aconf->name 
       * points to the actual irc name this server will be known as.
       * Now this new server has a set or even just one hub_mask (or leaf_mask)
       * given in the link list at yy_hconf. Fill in the HUB confs
       * from this link list now.
       */        
      DLINK_FOREACH_SAFE(ptr, next_ptr, hub_conf_list.head)
      {
	struct ConfItem *new_hub_conf;
	struct MatchItem *match_item;

	yy_hconf = ptr->data;

	/* yy_conf == NULL is a fatal error for this connect block! */
	if ((yy_conf != NULL) && (yy_conf->name != NULL))
	{
	  new_hub_conf = make_conf_item(HUB_TYPE);
	  match_item = (struct MatchItem *)map_to_conf(new_hub_conf);
	  DupString(new_hub_conf->name, yy_conf->name);
	  if (yy_hconf->user != NULL)
	    DupString(match_item->user, yy_hconf->user);
	  else
	    DupString(match_item->user, "*");
	  if (yy_hconf->host != NULL)
	    DupString(match_item->host, yy_hconf->host);
	  else
	    DupString(match_item->host, "*");
	}
	dlinkDelete(&yy_hconf->node, &hub_conf_list);
	free_collect_item(yy_hconf);
      }

      /* Ditto for the LEAF confs */

      DLINK_FOREACH_SAFE(ptr, next_ptr, leaf_conf_list.head)
      {
	struct ConfItem *new_leaf_conf;
	struct MatchItem *match_item;

	yy_lconf = ptr->data;

	if ((yy_conf != NULL) && (yy_conf->name != NULL))
	{
	  new_leaf_conf = make_conf_item(LEAF_TYPE);
	  match_item = (struct MatchItem *)map_to_conf(new_leaf_conf);
	  DupString(new_leaf_conf->name, yy_conf->name);
	  if (yy_lconf->user != NULL)
	    DupString(match_item->user, yy_lconf->user);
	  else
	    DupString(match_item->user, "*");
	  if (yy_lconf->host != NULL)
	    DupString(match_item->host, yy_lconf->host);
	  else
	    DupString(match_item->host, "*");
	}
	dlinkDelete(&yy_lconf->node, &leaf_conf_list);
	free_collect_item(yy_lconf);
      }
      MyFree(class_name);
      class_name = NULL;
      yy_conf = NULL;
      yy_aconf = NULL;
  }
}
break;
case 338:
#line 2256 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_conf->name != NULL)
      yyerror("Multiple connect name entry");

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 339:
#line 2268 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_conf->name != NULL)
      yyerror("Multiple connect name entry");

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 340:
#line 2280 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->host);
    DupString(yy_aconf->host, yylval.string);
  }
}
break;
case 341:
#line 2289 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_aconf->spasswd != NULL)
      memset(yy_aconf->spasswd, 0, strlen(yy_aconf->spasswd));

    MyFree(yy_aconf->spasswd);
    DupString(yy_aconf->spasswd, yylval.string);
  }
}
break;
case 342:
#line 2301 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_aconf->passwd != NULL)
      memset(yy_aconf->passwd, 0, strlen(yy_aconf->passwd));

    MyFree(yy_aconf->passwd);
    DupString(yy_aconf->passwd, yylval.string);
  }
}
break;
case 343:
#line 2313 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->port = yyvsp[-1].number;
}
break;
case 344:
#line 2319 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->aftype = AF_INET;
}
break;
case 345:
#line 2323 "ircd_parser.y"
{
#ifdef IPV6
  if (ypass == 2)
    yy_aconf->aftype = AF_INET6;
#endif
}
break;
case 346:
#line 2331 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->fakename);
    DupString(yy_aconf->fakename, yylval.string);
  }
}
break;
case 347:
#line 2340 "ircd_parser.y"
{
}
break;
case 351:
#line 2345 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags |= CONF_FLAGS_LAZY_LINK;
}
break;
case 352:
#line 2349 "ircd_parser.y"
{
  if (ypass == 2)
#ifndef HAVE_LIBZ
    yyerror("Ignoring flags = compressed; -- no zlib support");
#else
    yy_aconf->flags |= CONF_FLAGS_COMPRESSED;
#endif
}
break;
case 353:
#line 2357 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags |= CONF_FLAGS_CRYPTLINK;
}
break;
case 354:
#line 2361 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags |= CONF_FLAGS_ALLOW_AUTO_CONN;
}
break;
case 355:
#line 2365 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags |= CONF_FLAGS_BURST_AWAY;
}
break;
case 356:
#line 2371 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    BIO *file;

    if (yy_aconf->rsa_public_key != NULL)
    {
      RSA_free(yy_aconf->rsa_public_key);
      yy_aconf->rsa_public_key = NULL;
    }

    if (yy_aconf->rsa_public_key_file != NULL)
    {
      MyFree(yy_aconf->rsa_public_key_file);
      yy_aconf->rsa_public_key_file = NULL;
    }

    DupString(yy_aconf->rsa_public_key_file, yylval.string);

    if ((file = BIO_new_file(yylval.string, "r")) == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- file doesn't exist");
      break;
    }

    yy_aconf->rsa_public_key = (RSA *)PEM_read_bio_RSA_PUBKEY(file, NULL, 0, NULL);

    if (yy_aconf->rsa_public_key == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- Key invalid; check key syntax.");
      break;
    }
      
    BIO_set_close(file, BIO_CLOSE);
    BIO_free(file);
  }
#endif /* HAVE_LIBCRYPTO */
}
break;
case 357:
#line 2412 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_ENCRYPTED;
    else
      yy_aconf->flags &= ~CONF_FLAGS_ENCRYPTED;
  }
}
break;
case 358:
#line 2423 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_CRYPTLINK;
    else
      yy_aconf->flags &= ~CONF_FLAGS_CRYPTLINK;
  }
}
break;
case 359:
#line 2434 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
#ifndef HAVE_LIBZ
      yyerror("Ignoring compressed=yes; -- no zlib support");
#else
      yy_aconf->flags |= CONF_FLAGS_COMPRESSED;
#endif
    else
      yy_aconf->flags &= ~CONF_FLAGS_COMPRESSED;
  }
}
break;
case 360:
#line 2449 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_ALLOW_AUTO_CONN;
    else
      yy_aconf->flags &= ~CONF_FLAGS_ALLOW_AUTO_CONN;
  }
}
break;
case 361:
#line 2460 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;

    yy_tmp = (struct CollectItem *)MyMalloc(sizeof(struct CollectItem));
    DupString(yy_tmp->host, yylval.string);
    DupString(yy_tmp->user, "*");
    dlinkAdd(yy_tmp, &yy_tmp->node, &hub_conf_list);
  }
}
break;
case 362:
#line 2473 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;

    yy_tmp = (struct CollectItem *)MyMalloc(sizeof(struct CollectItem));
    DupString(yy_tmp->host, yylval.string);
    DupString(yy_tmp->user, "*");
    dlinkAdd(yy_tmp, &yy_tmp->node, &leaf_conf_list);
  }
}
break;
case 363:
#line 2486 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(class_name);
    DupString(class_name, yylval.string);
  }
}
break;
case 364:
#line 2495 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    struct EncCapability *ecap;
    const char *cipher_name;
    int found = 0;

    yy_aconf->cipher_preference = NULL;
    cipher_name = yylval.string;

    for (ecap = CipherTable; ecap->name; ecap++)
    {
      if ((irccmp(ecap->name, cipher_name) == 0) &&
          (ecap->cap & CAP_ENC_MASK))
      {
        yy_aconf->cipher_preference = ecap;
        found = 1;
        break;
      }
    }

    if (!found)
      yyerror("Invalid cipher");
  }
#else
  if (ypass == 2)
    yyerror("Ignoring cipher_preference -- no OpenSSL support");
#endif
}
break;
case 365:
#line 2530 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(KLINE_TYPE);
    yy_aconf = (struct AccessItem *)map_to_conf(yy_conf);
  }
}
break;
case 366:
#line 2537 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_aconf->user && yy_aconf->reason && yy_aconf->host)
    {
      if (yy_aconf->host != NULL)
        add_conf_by_address(CONF_KILL, yy_aconf);
    }
    else
      delete_conf_item(yy_conf);
    yy_conf = NULL;
    yy_aconf = NULL;
  }
}
break;
case 372:
#line 2556 "ircd_parser.y"
{
  if (ypass == 2)
  {
    DupString(yy_aconf->host, yylval.string);
    split_user_host(yy_aconf->host, &yy_aconf->user, &yy_aconf->host);
  }
}
break;
case 373:
#line 2565 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->reason);
    DupString(yy_aconf->reason, yylval.string);
  }
}
break;
case 374:
#line 2577 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(DLINE_TYPE);
    yy_aconf = (struct AccessItem *)map_to_conf(yy_conf);
    /* default reason */
    DupString(yy_aconf->reason, "NO REASON");
  }
}
break;
case 375:
#line 2586 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_aconf->host && parse_netmask(yy_aconf->host, NULL, NULL) != HM_HOST)
      add_conf_by_address(CONF_DLINE, yy_aconf);
    else
      delete_conf_item(yy_conf);
    yy_conf = NULL;
    yy_aconf = NULL;
  }
}
break;
case 381:
#line 2602 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->host);
    DupString(yy_aconf->host, yylval.string);
  }
}
break;
case 382:
#line 2611 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->reason);
    DupString(yy_aconf->reason, yylval.string);
  }
}
break;
case 383:
#line 2623 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(EXEMPTDLINE_TYPE);
    yy_aconf = (struct AccessItem *)map_to_conf(yy_conf);
    DupString(yy_aconf->passwd, "*");
  }
}
break;
case 384:
#line 2631 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_aconf->host && parse_netmask(yy_aconf->host, NULL, NULL) != HM_HOST)
      add_conf_by_address(CONF_EXEMPTDLINE, yy_aconf);
    else
      delete_conf_item(yy_conf);
    yy_conf = NULL;
    yy_aconf = NULL;
  }
}
break;
case 389:
#line 2647 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->host);
    DupString(yy_aconf->host, yylval.string);
  }
}
break;
case 390:
#line 2659 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(XLINE_TYPE);
    yy_match_item = (struct MatchItem *)map_to_conf(yy_conf);
    /* default reason */
    DupString(yy_match_item->reason,"Something about your name");
  }
}
break;
case 391:
#line 2668 "ircd_parser.y"
{
  /* XXX */
}
break;
case 397:
#line 2676 "ircd_parser.y"
{
  if (ypass == 2)
  {
    DupString(yy_conf->name, yylval.string);
    collapse(yy_conf->name);
  }
}
break;
case 398:
#line 2685 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_match_item->reason);
    DupString(yy_match_item->reason, yylval.string);
  }
}
break;
case 454:
#line 2733 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_min_cidr = yyvsp[-1].number;
}
break;
case 455:
#line 2739 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_min_cidr6 = yyvsp[-1].number;
}
break;
case 456:
#line 2745 "ircd_parser.y"
{
  if (ypass == 1) /* must be set in the 1st pass */
    ConfigFileEntry.burst_away = yylval.number;
}
break;
case 457:
#line 2751 "ircd_parser.y"
{
  ConfigFileEntry.tkline_expire_notices = yylval.number;
}
break;
case 458:
#line 2756 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.kill_chase_time_limit = yyvsp[-1].number;
}
break;
case 459:
#line 2762 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.hide_spoof_ips = yylval.number;
}
break;
case 460:
#line 2768 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.ignore_bogus_ts = yylval.number;
}
break;
case 461:
#line 2774 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.disable_remote = yylval.number;
}
break;
case 462:
#line 2780 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.failed_oper_notice = yylval.number;
}
break;
case 463:
#line 2786 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.anti_nick_flood = yylval.number;
}
break;
case 464:
#line 2792 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.max_nick_time = yyvsp[-1].number; 
}
break;
case 465:
#line 2798 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.max_nick_changes = yyvsp[-1].number;
}
break;
case 466:
#line 2804 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.max_accept = yyvsp[-1].number;
}
break;
case 467:
#line 2810 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.anti_spam_exit_message_time = yyvsp[-1].number;
}
break;
case 468:
#line 2816 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.ts_warn_delta = yyvsp[-1].number;
}
break;
case 469:
#line 2822 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.ts_max_delta = yyvsp[-1].number;
}
break;
case 470:
#line 2828 "ircd_parser.y"
{
  if ((yyvsp[-1].number > 0) && ypass == 1)
  {
    ilog(L_CRIT, "You haven't read your config file properly.");
    ilog(L_CRIT, "There is a line in the example conf that will kill your server if not removed.");
    ilog(L_CRIT, "Consider actually reading/editing the conf file, and removing this line.");
    exit(0);
  }
}
break;
case 471:
#line 2839 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.kline_with_reason = yylval.number;
}
break;
case 472:
#line 2845 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.kline_reason);
    DupString(ConfigFileEntry.kline_reason, yylval.string);
  }
}
break;
case 473:
#line 2854 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.warn_no_nline = yylval.number;
}
break;
case 474:
#line 2860 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.stats_o_oper_only = yylval.number;
}
break;
case 475:
#line 2866 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.stats_P_oper_only = yylval.number;
}
break;
case 476:
#line 2872 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.stats_k_oper_only = 2 * yylval.number;
}
break;
case 477:
#line 2876 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.stats_k_oper_only = 1;
}
break;
case 478:
#line 2882 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.stats_i_oper_only = 2 * yylval.number;
}
break;
case 479:
#line 2886 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.stats_i_oper_only = 1;
}
break;
case 480:
#line 2892 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.pace_wait = yyvsp[-1].number;
}
break;
case 481:
#line 2898 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.caller_id_wait = yyvsp[-1].number;
}
break;
case 482:
#line 2904 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.pace_wait_simple = yyvsp[-1].number;
}
break;
case 483:
#line 2910 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.short_motd = yylval.number;
}
break;
case 484:
#line 2916 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.no_oper_flood = yylval.number;
}
break;
case 485:
#line 2922 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.true_no_oper_flood = yylval.number;
}
break;
case 486:
#line 2928 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_pass_resv = yylval.number;
}
break;
case 487:
#line 2934 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (strlen(yylval.string) > LOCALE_LENGTH-2)
      yylval.string[LOCALE_LENGTH-1] = '\0';

    set_locale(yylval.string);
  }
}
break;
case 488:
#line 2945 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.idletime = yyvsp[-1].number;
}
break;
case 489:
#line 2951 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.dots_in_ident = yyvsp[-1].number;
}
break;
case 490:
#line 2957 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.maximum_links = yyvsp[-1].number;
}
break;
case 491:
#line 2963 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.max_targets = yyvsp[-1].number;
}
break;
case 492:
#line 2969 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.servlink_path);
    DupString(ConfigFileEntry.servlink_path, yylval.string);
  }
}
break;
case 493:
#line 2978 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    struct EncCapability *ecap;
    const char *cipher_name;
    int found = 0;

    ConfigFileEntry.default_cipher_preference = NULL;
    cipher_name = yylval.string;

    for (ecap = CipherTable; ecap->name; ecap++)
    {
      if ((irccmp(ecap->name, cipher_name) == 0) &&
          (ecap->cap & CAP_ENC_MASK))
      {
        ConfigFileEntry.default_cipher_preference = ecap;
        found = 1;
        break;
      }
    }

    if (!found)
      yyerror("Invalid cipher");
  }
#else
  if (ypass == 2)
    yyerror("Ignoring default_cipher_preference -- no OpenSSL support");
#endif
}
break;
case 494:
#line 3010 "ircd_parser.y"
{
  if (ypass == 2)
  {
    ConfigFileEntry.compression_level = yyvsp[-1].number;
#ifndef HAVE_LIBZ
    yyerror("Ignoring compression_level -- no zlib support");
#else
    if ((ConfigFileEntry.compression_level < 1) ||
        (ConfigFileEntry.compression_level > 9))
    {
      yyerror("Ignoring invalid compression_level, using default");
      ConfigFileEntry.compression_level = 0;
    }
#endif
  }
}
break;
case 495:
#line 3028 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.use_egd = yylval.number;
}
break;
case 496:
#line 3034 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.egdpool_path);
    DupString(ConfigFileEntry.egdpool_path, yylval.string);
  }
}
break;
case 497:
#line 3043 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.ping_cookie = yylval.number;
}
break;
case 498:
#line 3049 "ircd_parser.y"
{
  ConfigFileEntry.disable_auth = yylval.number;
}
break;
case 499:
#line 3054 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.throttle_time = yylval.number;
}
break;
case 500:
#line 3060 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes = 0;
}
break;
case 504:
#line 3067 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_BOTS;
}
break;
case 505:
#line 3071 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_CCONN;
}
break;
case 506:
#line 3075 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_DEBUG;
}
break;
case 507:
#line 3079 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_FULL;
}
break;
case 508:
#line 3083 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_SKILL;
}
break;
case 509:
#line 3087 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_NCHANGE;
}
break;
case 510:
#line 3091 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_REJ;
}
break;
case 511:
#line 3095 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_UNAUTH;
}
break;
case 512:
#line 3099 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_SPY;
}
break;
case 513:
#line 3103 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_EXTERNAL;
}
break;
case 514:
#line 3107 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_OPERWALL;
}
break;
case 515:
#line 3111 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_SERVNOTICE;
}
break;
case 516:
#line 3115 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_INVISIBLE;
}
break;
case 517:
#line 3119 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_WALLOP;
}
break;
case 518:
#line 3123 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_CALLERID;
}
break;
case 519:
#line 3127 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_umodes |= UMODE_LOCOPS;
}
break;
case 520:
#line 3133 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes = 0;
}
break;
case 524:
#line 3140 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_BOTS;
}
break;
case 525:
#line 3144 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_CCONN;
}
break;
case 526:
#line 3148 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_DEBUG;
}
break;
case 527:
#line 3152 "ircd_parser.y"
{ 
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_FULL;
}
break;
case 528:
#line 3156 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_SKILL;
}
break;
case 529:
#line 3160 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_NCHANGE;
}
break;
case 530:
#line 3164 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_REJ;
}
break;
case 531:
#line 3168 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_UNAUTH;
}
break;
case 532:
#line 3172 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_SPY;
}
break;
case 533:
#line 3176 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_EXTERNAL;
}
break;
case 534:
#line 3180 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_OPERWALL;
}
break;
case 535:
#line 3184 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_SERVNOTICE;
}
break;
case 536:
#line 3188 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_INVISIBLE;
}
break;
case 537:
#line 3192 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_WALLOP;
}
break;
case 538:
#line 3196 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_CALLERID;
}
break;
case 539:
#line 3200 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.oper_only_umodes |= UMODE_LOCOPS;
}
break;
case 540:
#line 3206 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.min_nonwildcard = yyvsp[-1].number;
}
break;
case 541:
#line 3212 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.min_nonwildcard_simple = yyvsp[-1].number;
}
break;
case 542:
#line 3218 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.default_floodcount = yyvsp[-1].number;
}
break;
case 543:
#line 3224 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.client_flood = yyvsp[-1].number;
}
break;
case 544:
#line 3230 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.dot_in_ip6_addr = yylval.number;
}
break;
case 545:
#line 3239 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(GDENY_TYPE);
    yy_aconf = (struct AccessItem *)map_to_conf(yy_conf);
    yy_aconf->flags = 0;
  }
}
break;
case 546:
#line 3247 "ircd_parser.y"
{
  if (ypass == 2)
  {
    /*
     * since we re-allocate yy_conf/yy_aconf after the end of action=, at the
     * end we will have one extra, so we should free it.
     */
    if (yy_conf->name == NULL && gdeny_items.length)
    {
      dlinkDelete(gdeny_items.tail, &gdeny_items);
      MyFree(yy_conf);
      yy_conf = NULL;
      yy_aconf = NULL;
    }
  }
}
break;
case 556:
#line 3274 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.glines = yylval.number;
}
break;
case 557:
#line 3280 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_time = yyvsp[-1].number;
}
break;
case 558:
#line 3286 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_logging = 0;
}
break;
case 562:
#line 3292 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_logging |= GDENY_REJECT;
}
break;
case 563:
#line 3296 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_logging |= GDENY_BLOCK;
}
break;
case 564:
#line 3302 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;

    if (yy_aconf->user == NULL)
    {
      DupString(yy_aconf->host, yylval.string);
      split_user_host(yy_aconf->host, &yy_aconf->user, &yy_aconf->host);
    }
    else
    {
      yy_tmp = (struct CollectItem *)MyMalloc(sizeof(struct CollectItem));

      DupString(yy_tmp->host, yylval.string);
      split_user_host(yy_tmp->host, &yy_tmp->user, &yy_tmp->host);

      dlinkAdd(yy_tmp, &yy_tmp->node, &col_conf_list);
    }
  }
}
break;
case 565:
#line 3325 "ircd_parser.y"
{
  if (ypass == 2)  
  {
    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 566:
#line 3334 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags = 0;
}
break;
case 567:
#line 3338 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;
    dlink_node *ptr, *next_ptr;

    DLINK_FOREACH_SAFE(ptr, next_ptr, col_conf_list.head)
    {
      struct AccessItem *new_aconf;
      struct ConfItem *new_conf;

      yy_tmp = ptr->data;
      new_conf = make_conf_item(GDENY_TYPE);
      new_aconf = (struct AccessItem *)map_to_conf(new_conf);

      new_aconf->flags = yy_aconf->flags;

      if (yy_conf->name != NULL)
        DupString(new_conf->name, yy_conf->name);
      else
        DupString(new_conf->name, "*");
      if (yy_aconf->user != NULL)
         DupString(new_aconf->user, yy_tmp->user);
      else   
        DupString(new_aconf->user, "*");
      if (yy_aconf->host != NULL)
        DupString(new_aconf->host, yy_tmp->host);
      else
        DupString(new_aconf->host, "*");

      dlinkDelete(&yy_tmp->node, &col_conf_list);
    }
    yy_conf = make_conf_item(GDENY_TYPE);
    yy_aconf = (struct AccessItem *)map_to_conf(yy_conf);
    yy_aconf->flags = 0;
  }
}
break;
case 570:
#line 3378 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags |= GDENY_REJECT;
}
break;
case 571:
#line 3382 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags |= GDENY_BLOCK;
}
break;
case 590:
#line 3411 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.disable_local_channels = yylval.number;
}
break;
case 591:
#line 3417 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.use_except = yylval.number;
}
break;
case 592:
#line 3423 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.use_invex = yylval.number;
}
break;
case 593:
#line 3429 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.use_knock = yylval.number;
}
break;
case 594:
#line 3435 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.knock_delay = yyvsp[-1].number;
}
break;
case 595:
#line 3441 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.knock_delay_channel = yyvsp[-1].number;
}
break;
case 596:
#line 3447 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.invite_ops_only = yylval.number;
}
break;
case 597:
#line 3453 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.max_chans_per_user = yyvsp[-1].number;
}
break;
case 598:
#line 3459 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.quiet_on_ban = yylval.number;
}
break;
case 599:
#line 3465 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.max_bans = yyvsp[-1].number;
}
break;
case 600:
#line 3471 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.default_split_user_count = yyvsp[-1].number;
}
break;
case 601:
#line 3477 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.default_split_server_count = yyvsp[-1].number;
}
break;
case 602:
#line 3483 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.no_create_on_split = yylval.number;
}
break;
case 603:
#line 3489 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigChannel.no_join_on_split = yylval.number;
}
break;
case 614:
#line 3509 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.flatten_links = yylval.number;
}
break;
case 615:
#line 3515 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.hide_servers = yylval.number;
}
break;
case 616:
#line 3521 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if ((yyvsp[-1].number > 0) && ConfigServerHide.links_disabled == 1)
    {
      eventAddIsh("write_links_file", write_links_file, NULL, yyvsp[-1].number);
      ConfigServerHide.links_disabled = 0;
    }

    ConfigServerHide.links_delay = yyvsp[-1].number;
  }
}
break;
case 617:
#line 3535 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.hidden = yylval.number;
}
break;
case 618:
#line 3541 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.disable_hidden = yylval.number;
}
break;
case 619:
#line 3547 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.hide_server_ips = yylval.number;
}
break;
#line 5525 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yysslim && yygrowstack())
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
